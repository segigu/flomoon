import { callAI, type AIMessage } from './aiClient';
import {
  ASTRO_PROFILES,
  PRIMARY_PROFILE_ID,
  type AstroProfile,
} from '../data/astroProfiles';
import { getCurrentUser } from '../data/userProfile.deprecated';
import type { UserProfileData, PartnerData } from './userContext';
import { getUserName, getPartnerName } from './userContext';
import {
  buildNatalChartAnalysis,
  type NatalChartAnalysis,
} from './astro';
import {
  findScenarioById,
  getFallbackContract,
  normalizePsychologicalContract,
  type PsychologicalContract,
  type ContractScenario,
} from '../data/psychologicalContracts';
import {
  getPsychContractHistorySnapshot,
  rememberContractUsage,
} from './psychContractHistory';
import {
  parseJsonWithRecovery,
  enforceSingleLine,
  clampString,
} from './promptPostprocessors';
import {
  NO_MYSTIC_RULES,
  EUROPE_CONTEXT_RULES,
  CHARACTER_NAME_RULES,
  STORY_CONTINUITY_RULES,
  STORY_STRUCTURE_POINTS,
  STORY_SCENE_REQUIREMENTS,
  CHOICE_REQUIREMENTS,
  JSON_FORMAT_RULES,
  RECENT_CONTRACT_RULES,
  buildMoonSummaryInstruction,
  FINALE_HUMAN_INTERPRETATION_RULES,
  FINALE_ASTRO_RULES,
  formatLifeSphereExamples,
  formatScenarioExamples,
} from '../data/storyGuidelines';

export interface HistoryStoryOption {
  id: string;
  title: string;
  description: string;
  /**
   * Indicates whether the option was generated by AI or proposed by the user.
   * Defaults to "ai" for backwards compatibility.
   */
  kind?: 'ai' | 'custom';
  /**
   * Raw transcript provided by the user (for custom options).
   */
  transcript?: string;
  /**
   * Any additional unformatted text that led to this option.
   */
  rawUserText?: string;
}

export interface HistoryStoryMeta {
  author: string;
  title: string;
  genre: string;
  contract: string;
  moonSummary: string; // Сообщение от Луны, подводящее итог диалога и объясняющее выбор темы
  arcLimit: number;
}

export interface HistoryStoryNodeInfo {
  arc: number;
  stage: string;
  scene: string;
}

export interface HistoryStoryFinale {
  resolution: string;
  humanInterpretation: string;
  astrologicalInterpretation: string;
}

export interface HistoryStoryResponse {
  meta?: HistoryStoryMeta;
  node?: HistoryStoryNodeInfo;
  options: HistoryStoryOption[];
  finale?: HistoryStoryFinale;
}

export interface HistoryStoryContextSegment {
  /**
   * Text that has already been shown to the user.
   */
  text: string;
  /**
   * Arc number associated with this segment.
   */
  arc: number;
  /**
   * Optional short title of the option that lead to this segment.
   */
  optionTitle?: string;
  /**
   * Optional explanation of the option that lead to this segment.
   */
  optionDescription?: string;
  /**
   * Raw transcript of the user's custom option (if any).
   */
  optionTranscript?: string;
  /**
   * Option origin.
   */
  optionKind?: 'ai' | 'custom';
}

export interface HistoryStoryAuthorStyle {
  name: string;
  stylePrompt: string;
  genre: string;
}

export interface HistoryStoryRequestOptions {
  /**
   * Previously generated story fragments, ordered chronologically.
   * The last element corresponds to the most recent paragraph.
   */
  segments: HistoryStoryContextSegment[];
  /**
   * Optional direction that the user выбрал для следующего шага.
   */
  currentChoice?: HistoryStoryOption;
  /**
   * Optional short summary of earlier events to reduce prompt length.
   */
  summary?: string;
  /**
   * Author persona that should narrate the story.
   */
  author: HistoryStoryAuthorStyle;
  /**
   * Total number of arcs expected in the story.
   */
  arcLimit: number;
  /**
   * Generation mode: either next arc or finale.
   */
  mode: 'arc' | 'finale';
  /**
   * Arc number that should be produced (required for arc mode).
   */
  currentArc?: number;
  /**
   * Previously established story contract, if any.
   */
  contract?: string;
  /**
   * Optional AbortSignal to cancel the AI request.
   */
  signal?: AbortSignal;
  /**
   * Optional Claude API key.
   */
  claudeApiKey?: string;
  /**
   * Optional Claude proxy URL.
   */
  claudeProxyUrl?: string;
  /**
   * Optional OpenAI API key for fallback.
   */
  openAIApiKey?: string;
  /**
   * Optional OpenAI proxy URL.
   */
  openAIProxyUrl?: string;
  /**
   * Language for AI prompts (ru, en, de).
   */
  language?: string;
  /**
   * Optional user profile from Supabase (for personalization).
   */
  userProfile?: UserProfileData | null;
  /**
   * Optional partner data from Supabase (for personalization).
   */
  userPartner?: PartnerData | null;
}

const STORY_STAGE_NAMES = [
  'Завязка',
  'Обострение',
  'Выбор',
  'Последствия',
  'Кульминация',
  'Поворотный момент',
] as const;

const STORY_STAGE_GUIDANCE: Record<string, string> = {
  Завязка: 'Покажи конкретную жизненную ситуацию, в которой проявляется внутренний конфликт. Обычная обстановка, реальные люди, понятная дилемма.',
  Обострение: 'Усиль давление: другие люди давят, обстоятельства требуют решения, время поджимает. Напряжение растёт.',
  Выбор: 'Героиня должна выбрать: пойти привычным путём (ловушка) или рискнуть попробовать по-другому.',
  Последствия: 'Покажи, что происходит после выбора. Реакции людей, собственные чувства, цена решения.',
  Кульминация: 'Самый острый момент: героиня сталкивается с главным страхом или болью этого конфликта.',
  'Поворотный момент': 'ВАЖНО: Это НЕ финал истории! Героиня делает ключевое действие или принимает решение, которое приведёт к развязке. Предпоследняя сцена перед финалом.',
};

const CONTEXT_LIMIT = 10; // Увеличено для лучшей связности истории (было 4)

function getFallbackOptions(language = 'ru'): [HistoryStoryOption, HistoryStoryOption] {
  if (language === 'en') {
    return [
      {
        id: 'stand-ground',
        title: 'Tell the truth',
        description: "Honestly voice your feelings and needs, even if it's uncomfortable.",
        kind: 'ai',
      },
      {
        id: 'stay-quiet',
        title: 'Stay silent',
        description: 'Stay silent for the sake of keeping the peace and avoiding conflict.',
        kind: 'ai',
      },
    ];
  }

  if (language === 'de') {
    return [
      {
        id: 'stand-ground',
        title: 'Wahrheit sagen',
        description: 'Ehrlich deine Gefühle und Bedürfnisse aussprechen, auch wenn es unbequem ist.',
        kind: 'ai',
      },
      {
        id: 'stay-quiet',
        title: 'Schweigen',
        description: 'Schweigen um des Friedens willen und um Konflikte zu vermeiden.',
        kind: 'ai',
      },
    ];
  }

  // Russian (default)
  return [
    {
      id: 'stand-ground',
      title: 'Сказать правду',
      description: 'Честно озвучить свои чувства и потребности, даже если это неудобно.',
      kind: 'ai',
    },
    {
      id: 'stay-quiet',
      title: 'Промолчать',
      description: 'Промолчать ради сохранения мира и избежания конфликта.',
      kind: 'ai',
    },
  ];
}

const FALLBACK_OPTIONS: [HistoryStoryOption, HistoryStoryOption] = getFallbackOptions();

const DEFAULT_CONTRACT = 'Могу ли я защитить свои границы, не чувствуя себя плохим человеком?';

// DEFAULT константы удалены - fallback больше не используется для сохранения целостности истории

/**
 * Получить астрологический профиль текущего пользователя.
 */
function getUserProfile(userProfile?: UserProfileData | null): AstroProfile {
  if (userProfile?.astroProfileId && typeof userProfile.astroProfileId === 'string') {
    const profileId = userProfile.astroProfileId as keyof typeof ASTRO_PROFILES;
    if (profileId in ASTRO_PROFILES) {
      return ASTRO_PROFILES[profileId];
    }
  }
  const user = getCurrentUser();
  return ASTRO_PROFILES[user.astroProfileId];
}

/**
 * Получить анализ натальной карты текущего пользователя.
 */
function getUserChartAnalysis(userProfile?: UserProfileData | null): NatalChartAnalysis {
  if (userProfile?.astroProfileId && typeof userProfile.astroProfileId === 'string') {
    const profileId = userProfile.astroProfileId as keyof typeof ASTRO_PROFILES;
    if (profileId in ASTRO_PROFILES) {
      return buildNatalChartAnalysis(profileId);
    }
  }
  const user = getCurrentUser();
  return buildNatalChartAnalysis(user.astroProfileId);
}

/**
 * Получить текстовое представление данных рождения текущего пользователя.
 */
function getUserBirthDataText(userProfile?: UserProfileData | null): string {
  return serializeBirthData(getUserProfile(userProfile));
}

/**
 * Получить текстовое представление анализа карты текущего пользователя.
 */
function getUserChartAnalysisText(userProfile?: UserProfileData | null): string {
  return serializeChartAnalysis(getUserChartAnalysis(userProfile));
}

interface PsychContractContext {
  contract: PsychologicalContract;
  scenario?: ContractScenario;
}

let activePsychContext: PsychContractContext | undefined;

function serializeBirthData(profile: AstroProfile): string {
  const locationNote = profile.notes?.split('(')[0]?.trim() ?? 'Тикси, Россия';
  const time = profile.birthTime ?? '12:00';
  return `{
  "date": "${profile.birthDate}",
  "time": "${time}",
  "timezone": "${profile.timeZone}",
  "location": "${locationNote}",
  "latitude": ${profile.latitude},
  "longitude": ${profile.longitude}
}`;
}

function serializeChartAnalysis(analysis: NatalChartAnalysis): string {
  const formatSection = (label: string, values: string[]): string => {
    if (!values.length) {
      return `${label}: []`;
    }
    return `${label}:\n- ${values.join('\n- ')}`;
  };

  return [
    formatSection('core_placements', analysis.corePlacements),
    formatSection('hard_aspects', analysis.hardAspects),
    formatSection('soft_aspects', analysis.softAspects),
  ].join('\n');
}

function indent(text: string, spaces = 2): string {
  const pad = ' '.repeat(spaces);
  return text
    .split('\n')
    .map(line => (line.length ? pad + line : line))
    .join('\n');
}

function joinSections(...sections: Array<string | false | undefined>): string {
  return sections.filter(Boolean).join('\n\n');
}

function getStageName(arc: number, arcLimit: number): string {
  const index = Math.max(0, Math.min(STORY_STAGE_NAMES.length - 1, arc - 1));
  return STORY_STAGE_NAMES[index] ?? STORY_STAGE_NAMES[STORY_STAGE_NAMES.length - 1];
}

function getStageGuidance(stage: string): string {
  return STORY_STAGE_GUIDANCE[stage] ?? '';
}

function trimString(value: unknown): string {
  return typeof value === 'string' ? value.trim() : '';
}

/**
 * System prompt builder for PsychContract generation
 */
function buildPsychContractSystemPrompt(language = 'ru'): string {
  if (language === 'en') {
    return 'You are a psychological story architect. Come up with new conflicts, avoid repetition, and respond only with JSON.';
  }

  if (language === 'de') {
    return 'Du bist ein psychologischer Geschichtenarchitekt. Erfinde neue Konflikte, vermeide Wiederholungen und antworte nur mit JSON.';
  }

  // Russian (default)
  return 'Ты психологический архитектор историй. Придумывай новые конфликты, избегай повторов и отвечай только JSON.';
}

/**
 * System prompt builder for main story generation
 */
function buildHistoryStorySystemPrompt(
  authorName: string,
  userName: string,
  systemPromptSuffix: string,
  language = 'ru',
): string {
  if (language === 'en') {
    return `You are ${authorName}, an English-speaking writer creating ONE cohesive interactive story in second person for ${userName}.

CRITICALLY IMPORTANT:
- This is ONE story that develops from beginning to end
- Each new scene is a direct continuation of the previous one
- Preserve all characters, their names, personalities, and spoken phrases
- Show direct consequences of the user's choices
- Don't start a new story — continue the existing one${systemPromptSuffix}`;
  }

  if (language === 'de') {
    return `Du bist ${authorName}, eine deutschsprachige Schriftstellerin, die EINE zusammenhängende interaktive Geschichte in der zweiten Person für ${userName} erstellt.

KRITISCH WICHTIG:
- Dies ist EINE Geschichte, die sich von Anfang bis Ende entwickelt
- Jede neue Szene ist eine direkte Fortsetzung der vorherigen
- Bewahre alle Charaktere, ihre Namen, Persönlichkeiten und gesprochenen Sätze
- Zeige direkte Konsequenzen der Entscheidungen des Benutzers
- Beginne keine neue Geschichte — setze die bestehende fort${systemPromptSuffix}`;
  }

  // Russian (default)
  return `Ты ${authorName}, русскоязычная писательница, создающая ОДНУ связную интерактивную историю во втором лице для ${userName}.

КРИТИЧЕСКИ ВАЖНО:
- Это ОДНА история, которая развивается от начала до конца
- Каждая новая сцена — прямое продолжение предыдущей
- Сохраняй всех персонажей, их имена, характеры, сказанные фразы
- Показывай прямые последствия выборов пользователя
- Не начинай новую историю — продолжай существующую${systemPromptSuffix}`;
}

/**
 * System prompt builder for custom voice option formatting
 */
function buildCustomOptionSystemPrompt(language = 'ru'): string {
  if (language === 'en') {
    return `Your task is to format the user's voice text into a choice card for the story.
PRIORITY: maximum closeness to the user's original text!

🚫 STRICTLY PROHIBITED:
- Change the meaning or intention of what the user said
- Add names, places, actions that are NOT in the original
- Change specific names ("Lea" → "friend")
- Add strong emotional descriptions ("with heartache", "joyfully")
- Invent psychological motives that the user didn't voice

✅ ALLOWED (minimally):
- Convert to grammatically correct form ("I'll go to mom" → "Go to mom")
- Expand slightly for clarity if text is too brief ("okay" → "Agree")
- Adapt to story context ONLY if user explicitly refers to it
- Fix obvious speech recognition errors

STRICT LIMITS (CANNOT EXCEED):
- Response format: clean JSON {"title": "...", "description": "..."} without Markdown and comments.
- Title: maximum 48 characters (3-6 words)
- Description: MAXIMUM 140 characters (including spaces and punctuation)
- If text doesn't fit — SHORTEN, keeping only the ESSENCE`;
  }

  if (language === 'de') {
    return `Deine Aufgabe ist es, den Sprachtext des Benutzers in eine Auswahlkarte für die Geschichte zu formatieren.
PRIORITÄT: maximale Nähe zum Originaltext des Benutzers!

🚫 STRIKT VERBOTEN:
- Den Sinn oder die Absicht dessen ändern, was der Benutzer sagte
- Namen, Orte, Handlungen hinzufügen, die NICHT im Original sind
- Spezifische Namen ändern ("Lea" → "Freundin")
- Starke emotionale Beschreibungen hinzufügen ("mit Herzschmerz", "freudig")
- Psychologische Motive erfinden, die der Benutzer nicht genannt hat

✅ ERLAUBT (minimal):
- In grammatikalisch korrekte Form bringen ("ich geh zu Mama" → "Zu Mama gehen")
- Leicht erweitern für Klarheit, wenn Text zu kurz ist ("okay" → "Zustimmen")
- An Geschichtskontext anpassen NUR wenn Benutzer explizit darauf verweist
- Offensichtliche Spracherkennungsfehler korrigieren

STRIKTE GRENZEN (DÜRFEN NICHT ÜBERSCHRITTEN WERDEN):
- Antwortformat: sauberes JSON {"title": "...", "description": "..."} ohne Markdown und Kommentare.
- Titel: maximal 48 Zeichen (3-6 Wörter)
- Beschreibung: MAXIMAL 140 Zeichen (einschließlich Leerzeichen und Interpunktion)
- Wenn Text nicht passt — KÜRZEN, nur die ESSENZ behalten`;
  }

  // Russian (default)
  return `Твоя задача — отформатировать голосовой текст пользователя в карточку выбора для истории.
ПРИОРИТЕТ: максимальная близость к оригинальному тексту пользователя!

🚫 СТРОГО ЗАПРЕЩЕНО:
- Менять смысл или намерение того, что сказал пользователь
- Добавлять имена, места, действия, которых НЕТ в оригинале
- Менять конкретные имена ("Лея" → "подруга")
- Добавлять сильные эмоциональные описания ("с болью в сердце", "радостно")
- Придумывать психологические мотивы, которых пользователь не озвучил

✅ РАЗРЕШЕНО (минимально):
- Привести к грамматически правильной форме ("пойду к маме" → "Пойти к маме")
- Немного раскрыть для понятности, если текст слишком краток ("окей" → "Согласиться")
- Адаптировать к контексту истории ТОЛЬКО если пользователь явно на неё ссылается
- Исправить очевидные ошибки распознавания речи

ЖЕСТКИЕ ЛИМИТЫ (НЕЛЬЗЯ ПРЕВЫШАТЬ):
- Формат ответа: чистый JSON {"title": "...", "description": "..."} без Markdown и комментариев.
- Название: максимум 48 символов (3-6 слов)
- Описание: МАКСИМУМ 140 символов (включая пробелы и знаки препинания)
- Если текст не влезает — СОКРАТИ, оставив только СУТЬ`;
}

/**
 * Умная замена переносов строк в JSON:
 * - Находит все строковые значения в JSON (между кавычками)
 * - Заменяет переносы строк внутри этих значений на пробелы
 * - Оставляет структурные элементы JSON (запятые, скобки) без изменений
 */
async function generatePsychContractContext(
  claudeApiKey?: string,
  claudeProxyUrl?: string,
  openAIApiKey?: string,
  openAIProxyUrl?: string,
  userProfile?: UserProfileData | null,
  userPartner?: PartnerData | null,
): Promise<PsychContractContext> {
  const historySnapshot = getPsychContractHistorySnapshot();
  const recentContractIds = historySnapshot.contracts.slice(0, 8).map(entry => entry.id);
  const recentScenarios = historySnapshot.scenarios.slice(0, 12).map(
    entry => `${entry.contractId}/${entry.scenarioId}`,
  );
  const diversifiedContractsBlockLines = RECENT_CONTRACT_RULES.split('\n');
  const diversifiedContractsBlock = [
    `6. ${diversifiedContractsBlockLines[0]}`,
    ...diversifiedContractsBlockLines.slice(1).map(line => `   ${line}`),
  ].join('\n');
  const lifeSphereExamples = formatLifeSphereExamples();
  const scenarioExamples = formatScenarioExamples();

  const userName = getUserName(userProfile);

  const prompt = joinSections(
    'Ты — психолог и драматургка, создающая интерактивные истории о внутреннем конфликте.',
    `Тебе нужно придумать свежий психологический контракт для ${userName}. Опираться надо на её натальную карту и избегать повторов прошлых контрактов/сцен.`,
    `🔹 ДАННЫЕ
birth_data:
${indent(getUserBirthDataText(userProfile), 2)}
chart_analysis:
${indent(getUserChartAnalysisText(userProfile), 2)}
recent_contract_ids: ${JSON.stringify(recentContractIds)}
recent_scenarios: ${JSON.stringify(recentScenarios)}`,
    `🔹 ЗАДАНИЕ
1. Осмысли психологическое напряжение карты и предложи НОВЫЙ внутренний конфликт (контракт).
2. Контракт должен быть простым, понятным вопросом из жизни — БЕЗ метафор и сложных формулировок.
3. Опиши 3 ловушки поведения (механизмы защиты, самообман).
4. Придумай 3 РЕАЛЬНЫЕ ЖИЗНЕННЫЕ СИТУАЦИИ (не мистику!).
   - ЗАПРЕЩЕНО: пустые метро, заброшенные дома, крыши, тёмные леса, замёрзшие озёра, любая мистика
   - НУЖНО: офис, квартира, кафе, парк, дом родителей, встреча с друзьями — обычные места
5. Добавь 3 ключевые точки выбора — конкретные жизненные дилеммы.
${diversifiedContractsBlock}
7. Чередуй 9 сфер жизни: работа, любовь, дружба, семья, саморазвитие, хобби, здоровье, финансы, творчество
8. Конкретные примеры контрактов по сферам:
${lifeSphereExamples}
9. ПРОВЕРЬ СЕБЯ: если твой контракт похож на что-то из recent_contract_ids — начни заново с другой сферы.`,
    `🔹 ПРИМЕРЫ СЦЕНАРИЕВ
${scenarioExamples}`,
    `🔹 ТРЕБОВАНИЯ К СТРУКТУРЕ
- contract.id — уникальный kebab-case латиницей без пробелов (например: career-vs-family).
- contract.question — простой понятный вопрос БЕЗ метафор (например: "Могу ли я отказать маме, если это важно для меня?").
- contract.theme — одно-два простых слова из жизни.
- contract.astroIndicators — 3–4 маркера (текстом, можно на русском).
- contract.commonTraps — массив из трёх объектов { "name": "...", "description": "..." }.
- contract.scenarios — массив из трёх РЕАЛЬНЫХ жизненных ситуаций { "id": "kebab-case", "setting": "ОБЫЧНОЕ МЕСТО (офис/кафе/дом)", "situation": "КОНКРЕТНАЯ ЖИЗНЕННАЯ СИТУАЦИЯ", "symbolism": "краткий смысл" }.
- contract.choicePoints — массив из трёх СТРОК (НЕ объектов!) с конкретными жизненными выборами. Пример: ["Остаться на работе или поехать в отпуск?", "Помочь подруге или отказать?", "Ответить на сообщение или игнорировать?"]
- recommendedScenarioId — id сцены, с которой лучше начать историю.
- Используй русский для описаний, но id оставь латиницей.`,
    `🔹 ФОРМАТ ОТВЕТА (JSON без форматирования, без комментариев):
{
  "contract": { ...см. выше... },
  "recommendedScenarioId": "scenario-id"
}`,
    JSON_FORMAT_RULES,
    'Не добавляй пояснений, текста вне JSON и Markdown.',
  );

  try {
    const result = await callAI({
      system: buildPsychContractSystemPrompt(),
      messages: [
        {
          role: 'user',
          content: prompt,
        },
      ],
      temperature: 0.85,
      maxTokens: 2500,
      claudeApiKey,
      claudeProxyUrl,
      openAIApiKey,
      openAIProxyUrl,
    });

    const { parsed } = parseJsonWithRecovery<any>(result.text, 'PsychContract');

    console.log('[PsychContract] Parsed response:', JSON.stringify(parsed, null, 2));

    const contract = normalizePsychologicalContract(parsed?.contract ?? parsed);
    if (!contract) {
      console.error('[PsychContract] Failed to normalize contract. Raw data:', parsed);
      throw new Error('Модель вернула некорректный контракт');
    }

    console.log('[PsychContract] ✅ Contract validated:', contract.id, contract.question);

    const recommendedScenarioId = trimString(
      parsed?.recommendedScenarioId ?? parsed?.recommended_scenario_id ?? '',
    );
    const scenario = findScenarioById(contract, recommendedScenarioId);

    rememberContractUsage(contract.id, scenario.id);

    return {
      contract,
      scenario,
    };
  } catch (error) {
    console.warn('[PsychContract] Failed to generate via AI, using fallback', error);
    const fallback = getFallbackContract(recentContractIds, recentScenarios);
    const fallbackScenario = findScenarioById(
      fallback.contract,
      fallback.recommendedScenarioId,
    );
    rememberContractUsage(fallback.contract.id, fallbackScenario.id);
    return {
      contract: fallback.contract,
      scenario: fallbackScenario,
    };
  }
}

async function ensurePsychContractContext(
  claudeApiKey?: string,
  claudeProxyUrl?: string,
  openAIApiKey?: string,
  openAIProxyUrl?: string,
  userProfile?: UserProfileData | null,
  userPartner?: PartnerData | null,
): Promise<PsychContractContext> {
  if (activePsychContext) {
    return activePsychContext;
  }

  activePsychContext = await generatePsychContractContext(
    claudeApiKey,
    claudeProxyUrl,
    openAIApiKey,
    openAIProxyUrl,
    userProfile,
    userPartner,
  );
  return activePsychContext;
}

export function clearPsychContractContext(): void {
  activePsychContext = undefined;
}

function buildPsychologicalContractInfo(
  contract?: PsychologicalContract,
  scenario?: ContractScenario,
): string {
  if (!contract) {
    return '';
  }

  const trapsText = contract.commonTraps
    .map(trap => `• ${trap.name}: ${trap.description}`)
    .join('\n');

  const scenarioText = scenario
    ? `Рекомендуемый сценарий:
- Обстановка: ${scenario.setting}
- Ситуация: ${scenario.situation}
- Символизм: ${scenario.symbolism}`
    : '';

  return `
🔹 ПСИХОЛОГИЧЕСКИЙ КОНТРАКТ

Основной вопрос: «${contract.question}»
Тема: ${contract.theme}

Типичные психологические ловушки:
${trapsText}

Ключевые точки выбора:
${contract.choicePoints.map(point => `• ${point}`).join('\n')}

${scenarioText}

ВАЖНО: На каждом этапе истории проверяй, не попадает ли героиня в одну из ловушек.
Выборы должны раскрывать эти ловушки и давать возможность увидеть паттерн.`;
}

function buildStorySoFar(
  segments: HistoryStoryContextSegment[],
  arcLimit: number,
  summary?: string,
  userProfile?: UserProfileData | null,
  userPartner?: PartnerData | null,
): string {
  if (!segments.length) {
    return 'История ещё не началась.';
  }

  const recentSegments = segments.slice(-CONTEXT_LIMIT);

  const parts = recentSegments.map((segment, index) => {
    const stage = getStageName(segment.arc, arcLimit);
    const choiceDetails: string[] = [];
    if (segment.optionTitle) {
      const base = `>>> Выбор, который привёл к этой сцене: «${segment.optionTitle}»`;
      const withDescription = segment.optionDescription
        ? `${base} — ${segment.optionDescription}`
        : base;
      choiceDetails.push(withDescription);
    } else {
      choiceDetails.push('>>> Начальная сцена');
    }

    if (segment.optionTranscript && segment.optionTranscript.trim().length > 0) {
      const userName = getUserName(userProfile);
      choiceDetails.push(`>>> Дословно ${userName} сказала: "${segment.optionTranscript.trim()}"`);
    }

    const choiceLine = choiceDetails.join('\n');
    const sceneLabel = `[Сцена ${segment.arc}/${arcLimit}: ${stage}]`;
    return `${sceneLabel}\n${choiceLine}\n${segment.text}`;
  });

  if (summary && summary.trim().length > 0) {
    return `${summary.trim()}\n\n${parts.join('\n\n')}`;
  }

  return parts.join('\n\n');
}

function buildInputDataBlock(genre: string, arcLimit: number, userProfile?: UserProfileData | null, userPartner?: PartnerData | null): string {
  const userName = getUserName(userProfile);
  return `🔹 ВХОДНЫЕ ДАННЫЕ

user_name: ${userName}
birth_data:
${indent(getUserBirthDataText(userProfile), 2)}
chart_analysis:
${indent(getUserChartAnalysisText(userProfile), 2)}
story_genre: ${genre}
arc_limit: ${arcLimit}
language: ru`;
}

interface ArcPromptArgs {
  segments: HistoryStoryContextSegment[];
  currentChoice?: HistoryStoryOption;
  summary?: string;
  author: HistoryStoryAuthorStyle;
  arcLimit: number;
  currentArc: number;
  contract?: string;
}

/**
 * Helper: Build transcript note for custom voice options
 */
function buildTranscriptNote(transcript: string, language = 'ru'): string {
  if (language === 'en') {
    return `

⚠️⚠️⚠️ THIS IS USER'S VOICE INPUT — FOLLOW IT LITERALLY! ⚠️⚠️⚠️

User SAID IN THEIR OWN WORDS: "${transcript.trim()}"

CRITICALLY IMPORTANT - SHOW THE MOMENT OF ACTION:
1. If an ACTION is named (ask, call, say, go) — show HOW it happens RIGHT NOW, NOT the result after
2. If NAMES are mentioned (Lena, mom) — use EXACTLY THESE names, don't replace with "friend", "close ones"
3. If PLACES are mentioned (office, cafe, home) — action happens EXACTLY THERE
4. DON'T write "After..." or "You already..." — show action IN PROGRESS

CRITICAL MISTAKE YOU MAKE:
❌ "Ask Lena for a loan" → DON'T WRITE: "After talking to Lena you're standing..."
✅ "Ask Lena for a loan" → CORRECT: "You approach Lena. 'Len, can you lend me money for a dress? I'll pay back in a couple months.' She stops, looks at you..."

❌ "Call mom" → DON'T WRITE: "After calling mom you feel..."
✅ "Call mom" → CORRECT: "You dial the number. — Mom, hi... — you begin. — Sweetheart! — mom's voice is warm..."

❌ "Go to Lea to discuss" → DON'T WRITE: "You decided to talk to your friend..."
✅ "Go to Lea to discuss" → CORRECT: "You go to Lea. She opens the door. — Hi, what happened? — seeing your face, she understands immediately..."

REMEMBER: The scene starts FROM THE BEGINNING of the action the user named, not after its completion!`;
  }

  if (language === 'de') {
    return `

⚠️⚠️⚠️ DIES IST DIE SPRACHEINGABE DES BENUTZERS — FOLGE IHR WÖRTLICH! ⚠️⚠️⚠️

Benutzer SAGTE IN EIGENEN WORTEN: "${transcript.trim()}"

KRITISCH WICHTIG - ZEIGE DEN MOMENT DER HANDLUNG:
1. Wenn eine HANDLUNG genannt wird (bitten, anrufen, sagen, gehen) — zeige WIE es JETZT GERADE passiert, NICHT das Ergebnis danach
2. Wenn NAMEN erwähnt werden (Lena, Mama) — verwende GENAU DIESE Namen, ersetze sie nicht durch "Freundin", "Nahestehende"
3. Wenn ORTE erwähnt werden (Büro, Cafe, Zuhause) — Handlung findet GENAU DORT statt
4. Schreibe NICHT "Nachdem..." oder "Du hast bereits..." — zeige Handlung IM PROZESS

KRITISCHER FEHLER, DEN DU MACHST:
❌ "Lena um Geld bitten" → Schreibe NICHT: "Nach dem Gespräch mit Lena stehst du..."
✅ "Lena um Geld bitten" → RICHTIG: "Du gehst zu Lena. 'Lena, kannst du mir Geld für ein Kleid leihen? Ich zahle in ein paar Monaten zurück.' Sie hält inne, sieht dich an..."

❌ "Mama anrufen" → Schreibe NICHT: "Nach dem Anruf bei Mama fühlst du..."
✅ "Mama anrufen" → RICHTIG: "Du wählst die Nummer. — Mama, hallo... — beginnst du. — Liebling! — Mamas Stimme ist warm..."

❌ "Zu Lea gehen, um zu besprechen" → Schreibe NICHT: "Du hast beschlossen, mit deiner Freundin zu sprechen..."
✅ "Zu Lea gehen, um zu besprechen" → RICHTIG: "Du gehst zu Lea. Sie öffnet die Tür. — Hallo, was ist passiert? — als sie dein Gesicht sieht, versteht sie sofort..."

MERKE: Die Szene beginnt AM ANFANG der Handlung, die der Benutzer genannt hat, nicht nach ihrer Vollendung!`;
  }

  // Russian (default)
  return `

⚠️⚠️⚠️ ЭТО ГОЛОСОВОЙ ВАРИАНТ ПОЛЬЗОВАТЕЛЯ — СЛЕДУЙ ЕМУ БУКВАЛЬНО! ⚠️⚠️⚠️

Пользователь СКАЗАЛ СВОИМИ СЛОВАМИ: "${transcript.trim()}"

КРИТИЧЕСКИ ВАЖНО - ПОКАЖИ МОМЕНТ ДЕЙСТВИЯ:
1. Если названо ДЕЙСТВИЕ (попросить, позвонить, сказать, пойти) — покажи КАК это происходит ПРЯМО СЕЙЧАС, а НЕ результат после
2. Если названы ИМЕНА (Лена, Ленка, мама) — используй ТОЧНО ЭТИ имена, не заменяй на "подруга", "близкие"
3. Если названы МЕСТА (офис, кафе, дом) — действие происходит ИМЕННО ТАМ
4. НЕ пиши "После того как..." или "Ты уже..." — покажи действие В ПРОЦЕССЕ

КРИТИЧЕСКАЯ ОШИБКА, КОТОРУЮ ТЫ ДЕЛАЕШЬ:
❌ "Попросить у Лены в долг" → НЕ ПИШИ: "После разговора с Леной ты стоишь..."
✅ "Попросить у Лены в долг" → ПРАВИЛЬНО: "Ты подходишь к Лене. 'Лен, можешь одолжить мне денег на платье? Верну через пару месяцев.' Она останавливается, смотрит на тебя..."

❌ "Позвонить маме" → НЕ ПИШИ: "После звонка маме ты чувствуешь..."
✅ "Позвонить маме" → ПРАВИЛЬНО: "Ты набираешь номер. — Мам, привет... — начинаешь ты. — Солнышко! — мамин голос теплый..."

❌ "Пойти к Лее обсудить" → НЕ ПИШИ: "Ты решила поговорить с подругой..."
✅ "Пойти к Лее обсудить" → ПРАВИЛЬНО: "Ты идёшь к Лее. Она открывает дверь. — Привет, что случилось? — видя твоё лицо, она сразу понимает..."

ПОМНИ: Сцена начинается С НАЧАЛА действия, которое назвал пользователь, а не после его завершения!`;
}

function buildArcPrompt(args: ArcPromptArgs, psychContext?: PsychContractContext, language = 'ru', userProfile?: UserProfileData | null, userPartner?: PartnerData | null): string {
  const {
    segments,
    currentChoice,
    summary,
    author,
    arcLimit,
    currentArc,
    contract,
  } = args;

  const stage = getStageName(currentArc, arcLimit);
  const stageGuidance = getStageGuidance(stage);
  const storyContext = buildStorySoFar(segments, arcLimit, summary, userProfile, userPartner);

  const hasCustomChoice = currentChoice?.kind === 'custom' && currentChoice.transcript;
  const transcriptNote = hasCustomChoice && currentChoice?.transcript
    ? buildTranscriptNote(currentChoice.transcript, language)
    : currentChoice?.transcript
      ? (language === 'en'
          ? `
User said: "${currentChoice.transcript.trim()}". All key details from this phrase must be clearly reflected in the scene.`
          : language === 'de'
          ? `
Benutzer sagte: "${currentChoice.transcript.trim()}". Alle wichtigen Details aus diesem Satz müssen sich deutlich in der Szene widerspiegeln.`
          : `
Пользователь произнёс: "${currentChoice.transcript.trim()}". Все ключевые детали из этой фразы должны явно отразиться в сцене.`)
      : '';

  const userName = getUserName(userProfile);

  const choiceInstruction = currentChoice
    ? (language === 'en'
        ? `CRITICALLY IMPORTANT: This is a continuation of ONE story!
Previous choice by ${userName}: "${currentChoice.title}"${currentChoice.description ? ` (${currentChoice.description})` : ''}.${transcriptNote}
The new scene must be a DIRECT CONSEQUENCE of this choice.
Show what happened AFTER she made this choice.
Preserve all characters, location, and situation from previous scenes.
CANNOT reset the choice, change it to opposite, or ignore consequences.`
        : language === 'de'
        ? `KRITISCH WICHTIG: Dies ist eine Fortsetzung EINER Geschichte!
Vorherige Wahl von ${userName}: „${currentChoice.title}"${currentChoice.description ? ` (${currentChoice.description})` : ''}.${transcriptNote}
Die neue Szene muss eine DIREKTE KONSEQUENZ dieser Wahl sein.
Zeige, was NACHDEM sie diese Wahl getroffen hat, passiert ist.
Bewahre alle Charaktere, den Ort und die Situation aus den vorherigen Szenen.
NICHT die Wahl zurücksetzen, ins Gegenteil ändern oder Konsequenzen ignorieren.`
        : `КРИТИЧЕСКИ ВАЖНО: Это продолжение ОДНОЙ истории!
Предыдущий выбор ${userName}: «${currentChoice.title}»${currentChoice.description ? ` (${currentChoice.description})` : ''}.${transcriptNote}
Новая сцена должна быть ПРЯМЫМ ПОСЛЕДСТВИЕМ этого выбора.
Покажи, что произошло ПОСЛЕ того, как она сделала этот выбор.
Сохраняй всех персонажей, место действия и ситуацию из предыдущих сцен.
НЕЛЬЗЯ обнулять выбор, менять его на противоположный или игнорировать последствия.`)
    : (language === 'en'
        ? 'This is the first node — start immediately with a specific situation as described in the recommended scenario.'
        : language === 'de'
        ? 'Dies ist der erste Knoten — beginne sofort mit einer konkreten Situation, wie im empfohlenen Szenario beschrieben.'
        : 'Это первый узел — начинай сразу с конкретной ситуации, как описано в рекомендуемом сценарии.');

  const psychContract = psychContext?.contract;
  const psychScenario = currentArc === 1 ? psychContext?.scenario : undefined;

  const contractInstruction = contract
    ? (language === 'en'
        ? `Story contract is already set: "${contract}". Keep the wording unchanged and remind yourself of it when creating scenes.`
        : language === 'de'
        ? `Geschichtskontrakt ist bereits festgelegt: „${contract}". Behalte die Formulierung unverändert bei und erinnere dich daran beim Erstellen von Szenen.`
        : `Контракт истории уже задан: «${contract}». Сохраняй формулировку без изменений и напоминай себе о нём при создании сцен.`)
    : psychContract
      ? (language === 'en'
          ? `Story contract: "${psychContract.question}". Use this contract on all nodes without changes.`
          : language === 'de'
          ? `Geschichtskontrakt: „${psychContract.question}". Verwende diesen Kontrakt auf allen Knoten ohne Änderungen.`
          : `Контракт истории: «${psychContract.question}». Используй этот контракт на всех узлах без изменений.`)
      : (language === 'en'
          ? 'Story contract will be set automatically.'
          : language === 'de'
          ? 'Geschichtskontrakt wird automatisch festgelegt.'
          : 'Контракт истории будет задан автоматически.');

  const stageSection = joinSections(
    language === 'en'
      ? `Now we need to create node ${currentArc} of ${arcLimit} — "${stage}".`
      : language === 'de'
      ? `Jetzt müssen wir Knoten ${currentArc} von ${arcLimit} erstellen — „${stage}".`
      : `Сейчас нужно создать узел ${currentArc} из ${arcLimit} — «${stage}».`,
    currentArc === arcLimit
      ? (language === 'en'
          ? `⚠️ IMPORTANT: This is node ${currentArc}, but this is NOT YET the story FINALE!
After this node there will be a separate final block with denouement and interpretation.
Your task here: create the penultimate scene and give the heroine the LAST choice.
DON'T end the story, DON'T write denouement — just one more scene with a choice!`
          : language === 'de'
          ? `⚠️ WICHTIG: Dies ist Knoten ${currentArc}, aber das ist NOCH NICHT das FINALE der Geschichte!
Nach diesem Knoten wird es noch einen separaten Finalblock mit Auflösung und Interpretation geben.
Deine Aufgabe hier: erstelle die vorletzte Szene und gib der Heldin die LETZTE Wahl.
Beende NICHT die Geschichte, schreibe KEINE Auflösung — nur noch eine Szene mit einer Wahl!`
          : `⚠️ ВАЖНО: Это узел ${currentArc}, НО ЭТО ЕЩЁ НЕ ФИНАЛ истории!
После этого узла будет ещё отдельный финальный блок с развязкой и интерпретацией.
Твоя задача здесь: создать предпоследнюю сцену и дать героине ПОСЛЕДНИЙ выбор.
НЕ завершай историю, НЕ пиши развязку — только ещё одну сцену с выбором!`)
      : undefined,
    language === 'en'
      ? `Focus of this node: ${stageGuidance}`
      : language === 'de'
      ? `Fokus dieses Knotens: ${stageGuidance}`
      : `Фокус этого узла: ${stageGuidance}`,
    currentArc === 1 && psychScenario
      ? (language === 'en'
          ? 'MUST use the recommended scenario (see above in "Psychological Contract" block). Create a scene based on the specified setting and situation — this is a REAL place, REAL situation.'
          : language === 'de'
          ? 'MUSS das empfohlene Szenario verwenden (siehe oben im Block "Psychologischer Kontrakt"). Erstelle eine Szene basierend auf der angegebenen Umgebung und Situation — das ist ein REALER Ort, REALE Situation.'
          : 'ОБЯЗАТЕЛЬНО используй рекомендуемый сценарий (см. выше в блоке "Психологический контракт"). Создай сцену на основе указанной обстановки и ситуации — это РЕАЛЬНОЕ место, РЕАЛЬНАЯ ситуация.')
      : undefined,
    choiceInstruction,
    contractInstruction,
  );

  const storyContextSection = language === 'en'
    ? `Story context (read CAREFULLY, these are events that already happened):
${storyContext}`
    : language === 'de'
    ? `Geschichtskontext (lies SORGFÄLTIG, das sind Ereignisse, die bereits passiert sind):
${storyContext}`
    : `Контекст истории (прочитай ВНИМАТЕЛЬНО, это уже произошедшие события):
${storyContext}`;

  const continuationSection =
    currentArc > 1
      ? (language === 'en'
          ? `CONTINUATION INSTRUCTIONS:
1. Reread ALL previous scenes above
2. Find character names, location, key phrases
3. Your new scene starts immediately after the last choice
4. Use the same names if characters are named
5. Show direct cause-effect relationship: choice → consequence
6. If hero chose "tell the truth", show HOW he said it and what they replied
7. If hero chose "stay silent", show HOW he stayed silent and what came of it`
          : language === 'de'
          ? `FORTSETZUNGSANWEISUNGEN:
1. Lies ALLE vorherigen Szenen oben erneut
2. Finde Charakternamen, Ort, Schlüsselsätze
3. Deine neue Szene beginnt sofort nach der letzten Wahl
4. Verwende die gleichen Namen, wenn Charaktere benannt sind
5. Zeige direkte Ursache-Wirkungs-Beziehung: Wahl → Konsequenz
6. Wenn Held "Wahrheit sagen" gewählt hat, zeige WIE er es sagte und was sie antworteten
7. Wenn Held "schweigen" gewählt hat, zeige WIE er schwieg und was daraus wurde`
          : `ИНСТРУКЦИЯ ПО ПРОДОЛЖЕНИЮ:
1. Перечитай ВСЕ предыдущие сцены выше
2. Найди имена персонажей, место действия, ключевые фразы
3. Твоя новая сцена начинается сразу после последнего выбора
4. Используй те же имена, если персонажи названы
5. Покажи прямую причинно-следственную связь: выбор → последствие
6. Если герой выбрал "сказать правду", покажи КАК он это сказал и что ответили
7. Если герой выбрал "промолчать", покажи КАК он промолчал и что из этого вышло`)
      : undefined;

  const moonSummaryInstruction = buildMoonSummaryInstruction().replace(/"/g, '\\"');
  const metaLines: string[] = [
    `    "author": "${author.name}"`,
    language === 'en'
      ? '    "title": "Brief story title (2-3 words reflecting contract essence)"'
      : language === 'de'
      ? '    "title": "Kurzer Geschichtstitel (2-3 Wörter, die die Essenz des Kontrakts widerspiegeln)"'
      : '    "title": "Краткое название истории (2-3 слова, отражающих суть контракта)"',
    language === 'en'
      ? '    "genre": "realism"'
      : language === 'de'
      ? '    "genre": "Realismus"'
      : '    "genre": "реализм"',
    language === 'en'
      ? '    "contract": "string"'
      : language === 'de'
      ? '    "contract": "Zeichenkette"'
      : '    "contract": "строка"',
  ];
  if (currentArc === 1) {
    metaLines.push(`    "moon_summary": "${moonSummaryInstruction}"`);
  }
  metaLines.push(`    "arc_limit": ${arcLimit}`);

  const jsonExample = language === 'en'
    ? `Answer strictly in JSON format:
{
  "meta": {
${metaLines.join(',\n')}
  },
  "node": {
    "arc": ${currentArc},
    "stage": "${stage}",
    "scene": "story paragraph"
  },
  "choices": [
    { "id": "unique-kebab-case", "title": "…", "description": "…" },
    { "id": "unique-kebab-case", "title": "…", "description": "…" }
  ]
}`
    : language === 'de'
    ? `Antworte strikt im JSON-Format:
{
  "meta": {
${metaLines.join(',\n')}
  },
  "node": {
    "arc": ${currentArc},
    "stage": "${stage}",
    "scene": "Geschichtsabsatz"
  },
  "choices": [
    { "id": "eindeutig-kebab-case", "title": "…", "description": "…" },
    { "id": "eindeutig-kebab-case", "title": "…", "description": "…" }
  ]
}`
    : `Ответь строго в формате JSON:
{
  "meta": {
${metaLines.join(',\n')}
  },
  "node": {
    "arc": ${currentArc},
    "stage": "${stage}",
    "scene": "абзац истории"
  },
  "choices": [
    { "id": "уникальный-kebab-case", "title": "…", "description": "…" },
    { "id": "уникальный-kebab-case", "title": "…", "description": "…" }
  ]
}`;

  const sections: Array<string | false | undefined> = [
    buildInputDataBlock(author.genre, arcLimit, userProfile, userPartner),
    psychContract ? buildPsychologicalContractInfo(psychContract, psychScenario) : undefined,
    language === 'en'
      ? '🔹 PROMPT (core for the model)'
      : language === 'de'
      ? '🔹 PROMPT (Kern für das Modell)'
      : '🔹 ПРОМПТ (ядро для модели)',
    language === 'en'
      ? 'Create a personal interactive story about a real life situation.'
      : language === 'de'
      ? 'Erstelle eine persönliche interaktive Geschichte über eine reale Lebenssituation.'
      : 'Создай персональную интерактивную историю о реальной жизненной ситуации.',
    language === 'en'
      ? `Base the theme and conflict on key aspects of user ${userName}'s natal chart:
chart_analysis is connected above — use corresponding motifs and tensions.`
      : language === 'de'
      ? `Basiere das Thema und den Konflikt auf Schlüsselaspekten des Geburtshoroskops von Benutzer ${userName}:
chart_analysis ist oben verbunden — verwende entsprechende Motive und Spannungen.`
      : `Основывай тему и конфликт на ключевых аспектах натальной карты пользователя ${userName}:
chart_analysis подключён выше — используй соответствующие мотивы и напряжения.`,
    language === 'en'
      ? `Author's style: ${author.stylePrompt}`
      : language === 'de'
      ? `Autorenstil: ${author.stylePrompt}`
      : `Авторский стиль: ${author.stylePrompt}`,
    language === 'en'
      ? 'Heroine — woman, name not mentioned.'
      : language === 'de'
      ? 'Heldin — Frau, Name nicht erwähnt.'
      : 'Героиня — женщина, имя не упоминается.',
    language === 'en'
      ? 'Narration is in second person ("you").'
      : language === 'de'
      ? 'Erzählung in der zweiten Person („du").'
      : 'Повествование ведётся от второго лица («ты»).',
    psychContract
      ? (language === 'en'
          ? `The story reveals a psychological contract: "${psychContract.question}". At each stage show how the heroine encounters typical traps of this contract (see above).`
          : language === 'de'
          ? `Die Geschichte enthüllt einen psychologischen Kontrakt: „${psychContract.question}". Zeige in jeder Phase, wie die Heldin auf typische Fallen dieses Kontrakts stößt (siehe oben).`
          : `История раскрывает психологический контракт: «${psychContract.question}». На каждом этапе показывай, как героиня сталкивается с типичными ловушками этого контракта (см. выше).`)
      : undefined,
    NO_MYSTIC_RULES,
    EUROPE_CONTEXT_RULES,
    CHARACTER_NAME_RULES,
    STORY_CONTINUITY_RULES,
    language === 'en'
      ? `Story structure:\n${STORY_STRUCTURE_POINTS.join('\n')}`
      : language === 'de'
      ? `Geschichtsstruktur:\n${STORY_STRUCTURE_POINTS.join('\n')}`
      : `Структура истории:\n${STORY_STRUCTURE_POINTS.join('\n')}`,
    stageSection,
    storyContextSection,
    continuationSection,
    STORY_SCENE_REQUIREMENTS,
    CHOICE_REQUIREMENTS,
    jsonExample,
    JSON_FORMAT_RULES,
    language === 'en'
      ? 'Do not add explanations, comments, Markdown, or emoji.'
      : language === 'de'
      ? 'Füge keine Erklärungen, Kommentare, Markdown oder Emoji hinzu.'
      : 'Не добавляй пояснений, комментариев, Markdown и эмодзи.',
  ];

  return joinSections(...sections);
}

interface FinalePromptArgs {
  segments: HistoryStoryContextSegment[];
  currentChoice?: HistoryStoryOption;
  summary?: string;
  author: HistoryStoryAuthorStyle;
  arcLimit: number;
  contract?: string;
}

function buildFinalePrompt(args: FinalePromptArgs, psychContext?: PsychContractContext, language = 'ru', userProfile?: UserProfileData | null, userPartner?: PartnerData | null): string {
  const {
    segments,
    currentChoice,
    summary,
    author,
    arcLimit,
    contract,
  } = args;

  const storyContext = buildStorySoFar(segments, arcLimit, summary, userProfile, userPartner);
  const userName = getUserName(userProfile);

  const hasCustomFinaleChoice = currentChoice?.kind === 'custom' && currentChoice.transcript;
  const finaleTranscriptNote = hasCustomFinaleChoice && currentChoice?.transcript
    ? (language === 'en'
        ? `

⚠️⚠️⚠️ FINAL CHOICE — USER'S VOICE INPUT! ⚠️⚠️⚠️

${userName} SAID IN HER OWN WORDS: "${currentChoice.transcript.trim()}"

CRITICALLY IMPORTANT - SHOW THE MOMENT OF ACTION IN DENOUEMENT:
1. Show HOW the action happens, NOT "after"
2. Use EXACT names/places from voice (Lena = "Lena", not "friend")
3. DON'T generalize action ("ask for loan" ≠ "seek help")
4. Denouement STARTS with this action, shows its process and consequences

CRITICAL MISTAKE:
❌ "Ask Lena for loan" → DON'T WRITE: "After talking to Lena you understood..."
✅ "Ask Lena for loan" → CORRECT: "You approached Lena. 'Len, can you lend me money for a dress?' She looked at you, paused for a second... 'You know, I'm tight myself right now...' And you suddenly felt relief..."

❌ "Call mom" → DON'T WRITE: "You sought support from close ones..."
✅ "Call mom" → CORRECT: "You called mom. — Mom, I need advice... — Hearing your voice, she immediately understood..."`
        : language === 'de'
        ? `

⚠️⚠️⚠️ FINALE WAHL — SPRACHEINGABE DES BENUTZERS! ⚠️⚠️⚠️

${userName} SAGTE IN IHREN EIGENEN WORTEN: "${currentChoice.transcript.trim()}"

KRITISCH WICHTIG - ZEIGE DEN MOMENT DER HANDLUNG IN DER AUFLÖSUNG:
1. Zeige WIE die Handlung passiert, NICHT "danach"
2. Verwende EXAKTE Namen/Orte aus der Stimme (Lena = "Lena", nicht "Freundin")
3. Verallgemeinere NICHT die Handlung ("um Geld bitten" ≠ "Hilfe suchen")
4. Auflösung BEGINNT mit dieser Handlung, zeigt ihren Prozess und Konsequenzen

KRITISCHER FEHLER:
❌ "Lena um Geld bitten" → Schreibe NICHT: "Nach dem Gespräch mit Lena hast du verstanden..."
✅ "Lena um Geld bitten" → RICHTIG: "Du gingst zu Lena. 'Lena, kannst du mir Geld für ein Kleid leihen?' Sie sah dich an, schwieg eine Sekunde... 'Weißt du, ich hab selbst gerade knapp...' Und du fühltest plötzlich Erleichterung..."

❌ "Mama anrufen" → Schreibe NICHT: "Du hast Unterstützung von Nahestehenden gesucht..."
✅ "Mama anrufen" → RICHTIG: "Du riefst Mama an. — Mama, ich brauche Rat... — Als sie deine Stimme hörte, verstand sie sofort..."`
        : `

⚠️⚠️⚠️ ФИНАЛЬНЫЙ ВЫБОР — ГОЛОСОВОЙ ВАРИАНТ ПОЛЬЗОВАТЕЛЯ! ⚠️⚠️⚠️

${userName} СКАЗАЛА СВОИМИ СЛОВАМИ: "${currentChoice.transcript.trim()}"

КРИТИЧЕСКИ ВАЖНО - ПОКАЖИ МОМЕНТ ДЕЙСТВИЯ В РАЗВЯЗКЕ:
1. Покажи КАК происходит действие, а НЕ "после того как"
2. Используй ТОЧНЫЕ имена/места из голоса (Лена/Ленка = "Лена", не "подруга")
3. НЕ обобщай действие ("попросить в долг" ≠ "обратиться за помощью")
4. Развязка НАЧИНАЕТСЯ с этого действия, показывает его процесс и последствия

КРИТИЧЕСКАЯ ОШИБКА:
❌ "Попросить у Лены в долг" → НЕ ПИШИ: "После разговора с Леной ты поняла..."
✅ "Попросить у Лены в долг" → ПРАВИЛЬНО: "Ты подошла к Лене. 'Лен, можешь одолжить денег на платье?' Она посмотрела на тебя, помолчала секунду... 'Знаешь, у меня сейчас самой туго...' И ты вдруг почувствовала облегчение..."

❌ "Позвонить маме" → НЕ ПИШИ: "Ты обратилась за поддержкой к близким..."
✅ "Позвонить маме" → ПРАВИЛЬНО: "Ты позвонила маме. — Мам, мне нужен совет... — Услышав твой голос, она сразу поняла..."`)
    : currentChoice?.transcript
      ? (language === 'en'
          ? ` ${userName} said literally: "${currentChoice.transcript.trim()}" — denouement must consider exactly this.`
          : language === 'de'
          ? ` ${userName} sagte wörtlich: "${currentChoice.transcript.trim()}" — Auflösung muss genau dies berücksichtigen.`
          : ` ${userName} сказала буквально: "${currentChoice.transcript.trim()}" — развязка должна учитывать именно это.`)
      : '';

  const choiceInstruction = currentChoice
    ? (language === 'en'
        ? `This is the final choice of ${userName}: "${currentChoice.title}"${
            currentChoice.description ? ` (${currentChoice.description})` : ''
          }. Build denouement as direct consequence of this step.${finaleTranscriptNote}`
        : language === 'de'
        ? `Dies ist die finale Wahl von ${userName}: „${currentChoice.title}"${
            currentChoice.description ? ` (${currentChoice.description})` : ''
          }. Baue Auflösung als direkte Konsequenz dieses Schrittes.${finaleTranscriptNote}`
        : `Это итоговый выбор ${userName}: «${currentChoice.title}»${
            currentChoice.description ? ` (${currentChoice.description})` : ''
          }. Построй развязку как прямое последствие этого шага.${finaleTranscriptNote}`)
    : (language === 'en'
        ? 'Consider that the final choice was made in favor of clarity — show consequences.'
        : language === 'de'
        ? 'Betrachte, dass die finale Wahl zugunsten der Klarheit getroffen wurde — zeige Konsequenzen.'
        : 'Считай, что итоговый выбор сделан в пользу ясности — покажи последствия.');

  const contractInstruction = contract
    ? (language === 'en'
        ? `Story contract: "${contract}". Stick to its tone in the denouement.`
        : language === 'de'
        ? `Geschichtskontrakt: „${contract}". Halte dich an seinen Ton in der Auflösung.`
        : `Контракт истории: «${contract}». Придерживайся его тона в развязке.`)
    : (language === 'en'
        ? 'The contract you formulated should manifest in the finale conclusions.'
        : language === 'de'
        ? 'Der von dir formulierte Kontrakt sollte sich in den Schlussfolgerungen des Finales manifestieren.'
        : 'Сформулированный тобой контракт должен проявиться в выводах финала.');

  const finaleRealismRules = language === 'en'
    ? `IMPORTANT: Finale must be REALISTIC and LIFE-LIKE:
- NO mysticism, metaphors, symbols
- Show specific reaction of heroine and those around her
- Describe real feelings and thoughts
- Concrete actions, not abstractions`
    : language === 'de'
    ? `WICHTIG: Finale muss REALISTISCH und LEBENSECHT sein:
- KEINE Mystik, Metaphern, Symbole
- Zeige spezifische Reaktion der Heldin und der Umgebenden
- Beschreibe echte Gefühle und Gedanken
- Konkrete Handlungen, keine Abstraktionen`
    : `ВАЖНО: Финал должен быть РЕАЛИСТИЧНЫМ и ЖИЗНЕННЫМ:
- НИКАКОЙ мистики, метафор, символов
- Покажи конкретную реакцию героини и окружающих
- Опиши реальные чувства и мысли
- Конкретные действия, а не абстракции`;

  const finaleBlockSection = joinSections(
    language === 'en'
      ? 'Form the final block:'
      : language === 'de'
      ? 'Forme den Finalblock:'
      : 'Сформируй финальный блок:',
    language === 'en'
      ? '- resolution — one paragraph of 3-5 sentences (60-90 words) that concludes the plot through CONCRETE actions and words, shows consequences of choice and closes tension;'
      : language === 'de'
      ? '- resolution — ein Absatz mit 3-5 Sätzen (60-90 Wörter), der die Handlung durch KONKRETE Handlungen und Worte abschließt, Konsequenzen der Wahl zeigt und Spannung auflöst;'
      : '- resolution — один абзац из 3–5 предложений (60–90 слов), который завершает сюжет через КОНКРЕТНЫЕ действия и слова, показывает последствия выбора и закрывает напряжение;',
    FINALE_HUMAN_INTERPRETATION_RULES,
    '',
    language === 'en'
      ? 'IMPORTANT FOR human_interpretation: Use healthy sarcasm and humor! If choices were strange or off-topic from contract — say it directly with irony.'
      : language === 'de'
      ? 'WICHTIG FÜR human_interpretation: Verwende gesunden Sarkasmus und Humor! Wenn Wahlen seltsam waren oder nicht zum Kontrakt passten — sage es direkt mit Ironie.'
      : 'ВАЖНО ДЛЯ human_interpretation: Используй здоровый сарказм и юмор! Если выборы были странными или не по теме контракта — скажи об этом прямо с иронией.',
    '',
    // Keep Russian examples as reference (they demonstrate the style)
    `Пример human_interpretation (обычный случай): "Твой выбор спрятаться на первом этапе — классическая осторожность, тут всё понятно. Но третий этап... Секунду, ты вдруг решила 'пойду смело навстречу'? После пяти сцен избегания? Либо внутренний герой проснулся, либо ты просто нажала не ту кнопку. На пятом этапе вернулась к привычной схеме 'лучше промолчу' — вот она, настоящая реакция. Интересно: где тут ты настоящая, а где играешь в смелую?"`,
    '',
    `Пример human_interpretation (абсурдные выборы): "Погоди... Контракт был про страх отказа маме, а ты на втором этапе решила написать пост в фейсбук про подругу Ленку? Это вообще о чём? Потом взяла деньги в долг у той же Ленки, потом призналась ей о парне... Окей, ты явно экспериментировала или проверяла, что будет. История про отношения с мамой куда-то уехала на второй план. Либо ты мастерски избегаешь настоящей темы, либо просто баловалась. Честно — похоже на второе."`,
    FINALE_ASTRO_RULES,
    `Пример формулировки: "Твой выбор уйти в тень на первом этапе логично объясняется Луной в 12-м доме (потребность в уединении и защите). Квадрат Сатурна к Луне добавил страха перед ошибкой. Но на третьем этапе ты резко выбрала 'пойти смело вперёд' — это ПРОТИВОРЕЧИТ и осторожной Луне, и медлительному Марсу в Тельце. У тебя нет импульсивных аспектов (Уран, Марс в огне), которые объясняли бы такой выбор. Возможно, ты выбрала не то, что чувствуешь, а то, что считаешь 'правильным' — социально одобряемую смелость вместо честной осторожности. На пятом этапе ты вернулась к паттерну Сатурна-Луны (контроль и защита) — вот она, настоящая реакция. Карта не врёт: твоя природа — это вдумчивость, не импульс."`,
    language === 'en'
      ? 'Keep second person and atmosphere, don\'t add new branches.'
      : language === 'de'
      ? 'Bewahre die zweite Person und Atmosphäre, füge keine neuen Verzweigungen hinzu.'
      : 'Сохраняй второе лицо и атмосферность, не добавляй новых развилок.',
  );

  const finaleJsonExample = language === 'en'
    ? `Answer strictly in JSON format (example):
{"meta":{"author":"${author.name}","title":"Brief story title (2-3 words)","genre":"realism","contract":"string","arc_limit":${arcLimit}},"finale":{"resolution":"denouement paragraph in one continuous line with spaces instead of line breaks","human_interpretation":"4-6 sentences in one continuous line: analysis of choices through character traits, without astrological terms","astrological_interpretation":"4-7 sentences in one continuous line: detailed astrological analysis of choices with planets, houses and aspects"}}`
    : language === 'de'
    ? `Antworte strikt im JSON-Format (Beispiel):
{"meta":{"author":"${author.name}","title":"Kurzer Geschichtstitel (2-3 Wörter)","genre":"Realismus","contract":"Zeichenkette","arc_limit":${arcLimit}},"finale":{"resolution":"Auflösungsabsatz in einer durchgehenden Zeile mit Leerzeichen statt Zeilenumbrüchen","human_interpretation":"4-6 Sätze in einer durchgehenden Zeile: Analyse der Wahlen durch Charaktereigenschaften, ohne astrologische Begriffe","astrological_interpretation":"4-7 Sätze in einer durchgehenden Zeile: detaillierte astrologische Analyse der Wahlen mit Planeten, Häusern und Aspekten"}}`
    : `Ответь строго в формате JSON (пример):
{"meta":{"author":"${author.name}","title":"Краткое название истории (2-3 слова)","genre":"реализм","contract":"строка","arc_limit":${arcLimit}},"finale":{"resolution":"абзац-развязка в одну непрерывную строку с пробелами вместо переносов","human_interpretation":"4-6 предложений в одну непрерывную строку: анализ выборов через черты характера, без астрологических терминов","astrological_interpretation":"4-7 предложений в одну непрерывную строку: детальный астрологический анализ выборов с планетами, домами и аспектами"}}`;

  const sections: Array<string | false | undefined> = [
    buildInputDataBlock(author.genre, arcLimit, userProfile, userPartner),
    psychContext ? `${buildPsychologicalContractInfo(psychContext.contract)}\n` : undefined,
    language === 'en'
      ? '🔹 PROMPT (core for the model)'
      : language === 'de'
      ? '🔹 PROMPT (Kern für das Modell)'
      : '🔹 ПРОМПТ (ядро для модели)',
    language === 'en'
      ? `You will complete the interactive story for ${userName}.`
      : language === 'de'
      ? `Du wirst die interaktive Geschichte für ${userName} abschließen.`
      : `Ты завершишь интерактивную историю для ${userName}.`,
    contractInstruction,
    choiceInstruction,
    language === 'en'
      ? `Maintain the author's style: ${author.stylePrompt}`
      : language === 'de'
      ? `Behalte den Autorenstil bei: ${author.stylePrompt}`
      : `Удерживай авторский стиль: ${author.stylePrompt}`,
    finaleRealismRules,
    EUROPE_CONTEXT_RULES,
    CHARACTER_NAME_RULES,
    STORY_CONTINUITY_RULES,
    language === 'en'
      ? `Story context:\n${storyContext}`
      : language === 'de'
      ? `Geschichtskontext:\n${storyContext}`
      : `Контекст истории:\n${storyContext}`,
    finaleBlockSection,
    finaleJsonExample,
    JSON_FORMAT_RULES,
    language === 'en'
      ? 'No explanations, only compact JSON in one line or with minimal line breaks between fields (but not inside string values).'
      : language === 'de'
      ? 'Keine Erklärungen, nur kompaktes JSON in einer Zeile oder mit minimalen Zeilenumbrüchen zwischen Feldern (aber nicht innerhalb von Zeichenkettenwerten).'
      : 'Никаких пояснений, только компактный JSON в одну строку или с минимальными переносами между полями (но не внутри строковых значений).',
  ];

  return joinSections(...sections);
}

function sanitizeOption(
  option: Partial<HistoryStoryOption> | undefined,
  fallback: HistoryStoryOption,
): HistoryStoryOption {
  if (!option) {
    return fallback;
  }

  const id = typeof option.id === 'string' && option.id.trim().length > 0
    ? option.id.trim()
    : fallback.id;

  const title = typeof option.title === 'string' && option.title.trim().length > 0
    ? clampString(enforceSingleLine(option.title), 48)
    : fallback.title;

  const description = typeof option.description === 'string' && option.description.trim().length > 0
    ? clampString(enforceSingleLine(option.description), 140)
    : fallback.description;

  return {
    id,
    title,
    description,
    kind: 'ai',
  };
}

interface NormalizeOptions {
  mode: 'arc' | 'finale';
  authorName: string;
  genre: string;
  arcLimit: number;
  currentArc: number;
  contract?: string;
}

export function normalizeResponse(raw: unknown, options: NormalizeOptions): HistoryStoryResponse {
  const contract = options.contract ?? DEFAULT_CONTRACT;

  if (options.mode === 'finale') {
    const metaSource = (raw as any)?.meta;
    const finaleSource = (raw as any)?.finale ?? raw;

    const resolvedContract =
      typeof metaSource?.contract === 'string' && metaSource.contract.trim().length > 0
        ? metaSource.contract.trim()
        : contract;

    const resolution =
      typeof finaleSource?.resolution === 'string' && finaleSource.resolution.trim().length > 0
        ? finaleSource.resolution.trim()
        : '';

    const humanInterpretation =
      typeof finaleSource?.human_interpretation === 'string' && finaleSource.human_interpretation.trim().length > 0
        ? finaleSource.human_interpretation.trim()
        : typeof finaleSource?.interpretation === 'string' && finaleSource.interpretation.trim().length > 0
          ? finaleSource.interpretation.trim()
          : '';

    const astrologicalInterpretation =
      typeof finaleSource?.astrological_interpretation === 'string' && finaleSource.astrological_interpretation.trim().length > 0
        ? finaleSource.astrological_interpretation.trim()
        : '';

    // Проверяем, что все части финала заполнены
    if (!resolution) {
      throw new Error('История замерла в предвкушении... 🎭 Попробуем снова?');
    }
    if (!humanInterpretation) {
      throw new Error('Психолог задумался слишком глубоко 🤔 Ещё разок?');
    }
    if (!astrologicalInterpretation) {
      throw new Error('Планеты выстроились в очередь за кофе ☕✨ Нажми "Попробовать снова"!');
    }

    return {
      meta: {
        author: typeof metaSource?.author === 'string' && metaSource.author.trim().length > 0
          ? metaSource.author.trim()
          : options.authorName,
        title: typeof metaSource?.title === 'string' && metaSource.title.trim().length > 0
          ? metaSource.title.trim()
          : 'Без названия',
        genre: 'реализм', // Всегда реализм, игнорируем ответ AI
        contract: resolvedContract,
        moonSummary: '', // Для finale не используется
        arcLimit: Number.isFinite(metaSource?.arc_limit)
          ? Number(metaSource.arc_limit)
          : options.arcLimit,
      },
      options: [],
      finale: {
        resolution,
        humanInterpretation,
        astrologicalInterpretation,
      },
    };
  }

  const metaSource = (raw as any)?.meta ?? (raw as any);
  const nodeSource = (raw as any)?.node ?? (raw as any);
  // Ищем choices внутри node или на верхнем уровне (для обратной совместимости)
  const choicesSource = Array.isArray(nodeSource?.choices)
    ? nodeSource.choices
    : Array.isArray(nodeSource?.options)
      ? nodeSource.options
      : Array.isArray((raw as any)?.choices)
        ? (raw as any).choices
        : Array.isArray((raw as any)?.options)
          ? (raw as any).options
          : [];

  const resolvedContract =
    typeof metaSource?.contract === 'string' && metaSource.contract.trim().length > 0
      ? metaSource.contract.trim()
      : contract;

  const rawMoonSummary =
    typeof metaSource?.moon_summary === 'string' ? enforceSingleLine(metaSource.moon_summary).trim() : '';
  const rawScene = typeof nodeSource?.scene === 'string' ? nodeSource.scene.trim() : '';
  const sceneText = rawScene ? enforceSingleLine(rawScene) : '';

  // Проверяем, что сцена не пустая
  if (!sceneText) {
    throw new Error('Сцена застряла между реальностями 🌀 Давай вытащим её обратно?');
  }

  const stageName =
    typeof nodeSource?.stage === 'string' && nodeSource.stage.trim().length > 0
      ? nodeSource.stage.trim()
      : getStageName(options.currentArc, options.arcLimit);

  const arcNumber = Number.isFinite(nodeSource?.arc)
    ? Math.max(1, Number(nodeSource.arc))
    : options.currentArc;

  // Проверяем, что есть хотя бы 2 опции
  if (!Array.isArray(choicesSource) || choicesSource.length < 2) {
    throw new Error('Развилка дорог потерялась в тумане 🌫️ Попробуем найти её снова?');
  }

  const normalizedOptions: HistoryStoryOption[] = [
    sanitizeOption(choicesSource[0], FALLBACK_OPTIONS[0]),
    sanitizeOption(choicesSource[1], FALLBACK_OPTIONS[1]),
  ];

  return {
    meta: {
      author: typeof metaSource?.author === 'string' && metaSource.author.trim().length > 0
        ? metaSource.author.trim()
        : options.authorName,
      title: typeof metaSource?.title === 'string' && metaSource.title.trim().length > 0
        ? enforceSingleLine(metaSource.title)
        : 'Без названия',
      genre: 'реализм', // Всегда реализм, игнорируем ответ AI
      contract: resolvedContract,
      moonSummary: rawMoonSummary.length > 0
        ? rawMoonSummary
        : '', // Пустая строка, если не первая дуга или не предоставлено
      arcLimit: Number.isFinite(metaSource?.arc_limit)
        ? Number(metaSource.arc_limit)
        : options.arcLimit,
    },
    node: {
      arc: arcNumber,
      stage: stageName,
      scene: sceneText,
    },
    options: normalizedOptions,
  };
}

export async function generateHistoryStoryChunk({
  segments,
  currentChoice,
  summary,
  author,
  arcLimit,
  mode,
  currentArc,
  contract,
  signal,
  claudeApiKey,
  claudeProxyUrl,
  openAIApiKey,
  openAIProxyUrl,
  language = 'ru',
  userProfile,
  userPartner,
}: HistoryStoryRequestOptions): Promise<HistoryStoryResponse> {
  const targetArc = mode === 'arc' ? (currentArc ?? 1) : arcLimit;
  let resolvedContract = contract;
  let psychContext: PsychContractContext | undefined;

  if (mode === 'arc') {
    if (targetArc === 1 && !contract) {
      psychContext = await ensurePsychContractContext(
        claudeApiKey,
        claudeProxyUrl,
        openAIApiKey,
        openAIProxyUrl,
        userProfile,
        userPartner,
      );
      resolvedContract = psychContext.contract.question;
    } else if (activePsychContext) {
      psychContext = activePsychContext;
      if (!resolvedContract) {
        resolvedContract = psychContext.contract.question;
      }
    }
  } else if (mode === 'finale' && activePsychContext) {
    psychContext = activePsychContext;
    if (!resolvedContract) {
      resolvedContract = psychContext.contract.question;
    }
  }

  const prompt =
    mode === 'finale'
      ? buildFinalePrompt(
          {
            segments,
            currentChoice,
            summary,
            author,
            arcLimit,
            contract: resolvedContract,
          },
          psychContext,
          language,
          userProfile,
          userPartner,
        )
      : buildArcPrompt(
          {
            segments,
            currentChoice,
            summary,
            author,
            arcLimit,
            currentArc: targetArc,
            contract: resolvedContract,
          },
          psychContext,
          language,
          userProfile,
          userPartner,
        );

  const messages: AIMessage[] = [
    {
      role: 'user',
      content: prompt,
    },
  ];

  const hasCustomChoiceForGeneration = currentChoice?.kind === 'custom' && currentChoice?.transcript;
  const systemPromptSuffix = hasCustomChoiceForGeneration
    ? `

🚨🚨🚨 ГОЛОСОВОЙ ВАРИАНТ ПОЛЬЗОВАТЕЛЯ - ОСОБЫЕ ПРАВИЛА! 🚨🚨🚨

Пользователь сказал свой вариант голосом. В промпте ты увидишь его дословный текст.

ОБЯЗАТЕЛЬНО:
1. Покажи МОМЕНТ действия, а не результат: если сказано "попросить у Лены в долг" — покажи КАК она просит ("Ты подходишь к Лене: 'Лен, можешь одолжить мне денег?'"), а НЕ "после того как попросила"
2. Используй ТОЧНЫЕ имена из голоса: если сказано "Ленка" или "Лена" — используй ЭТО имя, не "подруга" или "коллега"
3. НЕ пропускай действие: если сказано "позвонить маме" — покажи звонок с диалогом, не "после звонка"
4. НЕ обобщай: "попросить в долг" ≠ "обратиться за помощью"

❌ НЕПРАВИЛЬНО: "После разговора с Леной ты стоишь..."
✅ ПРАВИЛЬНО: "Ты подходишь к Лене. 'Лен, можешь одолжить мне денег на платье?' — она смотрит на тебя удивленно..."

Соблюдай формат JSON без Markdown и СТРОГО следуй голосовому варианту.`
    : `

Соблюдай формат JSON без Markdown и выполняй все требования пользователя.`;

  const userName = getUserName(userProfile);

  try {
    const result = await callAI({
      system: buildHistoryStorySystemPrompt(author.name, userName, systemPromptSuffix),
      messages,
      temperature: hasCustomChoiceForGeneration ? 0.5 : 0.85, // Снижаем temperature для голосовых вариантов
      maxTokens: mode === 'finale' ? 2000 : 1000, // Увеличено с 600 до 1000 для arc из-за более детальных промптов
      signal,
      claudeApiKey,
      claudeProxyUrl,
      openAIApiKey,
      openAIProxyUrl,
      // preferOpenAI не указываем - по умолчанию используется Claude первым
    });

    console.log(`[HistoryStory] Generated ${mode} using ${result.provider}`);

    const { parsed } = parseJsonWithRecovery(result.text, `HistoryStory:${mode}`);

    return normalizeResponse(parsed, {
      mode,
      authorName: author.name,
      genre: author.genre,
      arcLimit,
      currentArc: targetArc,
      contract: resolvedContract,
    });
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      throw error;
    }
    console.error(`[HistoryStory] Failed to generate ${mode}`, error);

    // НЕ используем fallback ни для finale, ни для arc
    // Fallback-сцены нарушают целостность истории
    if (mode === 'finale') {
      throw new Error('Звёзды отвлеклись на кофе-брейк 🌟☕ Давай попробуем ещё раз?');
    } else {
      throw new Error('Муза сбежала за вдохновением 🦋 Нажми "Попробовать снова" — она вернётся!');
    }
  }
}

export interface CustomHistoryOptionRequest {
  transcript: string;
  segments: HistoryStoryContextSegment[];
  summary?: string;
  author: HistoryStoryAuthorStyle;
  signal?: AbortSignal;
  claudeApiKey?: string;
  claudeProxyUrl?: string;
  openAIApiKey?: string;
  openAIProxyUrl?: string;
  userProfile?: UserProfileData | null;
  userPartner?: PartnerData | null;
}

const MIN_TRANSCRIPT_WORDS = 3;

export async function generateCustomHistoryOption({
  transcript,
  segments,
  summary,
  author,
  signal,
  claudeApiKey,
  claudeProxyUrl,
  openAIApiKey,
  openAIProxyUrl,
  userProfile,
  userPartner,
}: CustomHistoryOptionRequest): Promise<HistoryStoryOption> {
  const cleanedTranscript = transcript.trim();
  if (cleanedTranscript.length === 0) {
    throw new Error('Похоже, аудиозапись получилась пустой.');
  }

  const normalizedTranscript = cleanedTranscript.replace(/\s+/g, ' ').trim();
  const transcriptWordCount = normalizedTranscript.split(' ').filter(Boolean).length;
  if (transcriptWordCount < MIN_TRANSCRIPT_WORDS) {
    throw new Error('Мы записали только пару слов. Попробуй сформулировать вариант чуть подробнее и перезапиши.');
  }

  const recentSegments = segments.slice(-4);
  const contextLines = recentSegments
    .map((segment, index) => {
      const orderLabel = `${segment.arc}.${index + 1}`;
      const choicePrefix = segment.optionTitle
        ? `После выбора «${segment.optionTitle}». `
        : '';
      const text = clampString(segment.text.replace(/\s+/g, ' ').trim(), 220);
      return `${orderLabel}: ${choicePrefix}${text}`;
    })
    .join('\n');

  const storyContextSection = contextLines.length > 0
    ? `Недавние сцены:\n${contextLines}`
    : 'История только начинается.';

  const summarySection = summary && summary.trim().length > 0
    ? `Сводка прошлых событий: ${summary}`
    : undefined;

  const systemPrompt = buildCustomOptionSystemPrompt();

  const userPrompt = joinSections(
    storyContextSection,
    summarySection,
    '',
    'РАСПОЗНАННЫЙ ТЕКСТ ПОЛЬЗОВАТЕЛЯ:',
    `"""${normalizedTranscript}"""`,
    '',
    'Задача:',
    '1. Сделай краткое название (title): 3-6 слов, до 48 символов',
    '2. Сделай КРАТКОЕ описание (description): 1 предложение, СТРОГО до 140 символов',
    '3. Сохрани главное: имена, ключевое действие, суть',
    '4. Если текст длинный — СОКРАТИ, убрав детали и оставив суть',
    '5. ПРОВЕРЬ длину description — если больше 140 символов, сократи еще',
    '',
    'Примеры (обрати внимание на длину):',
    '',
    'Вход: "Пойду к Лее обсудить эту ситуацию"',
    '{"title": "Пойти к Лее", "description": "Пойти к Лее и обсудить ситуацию"}',
    '',
    'Вход: "Промолчу и сделаю вид что ничего не случилось"',
    '{"title": "Промолчать", "description": "Промолчать и сделать вид, что ничего не случилось"}',
    '',
    'Вход: "Написать пост в фейсбуке о том какая классная подруга Ленка и сколько денег она отдала намекая маме на то как тебе тяжело в надежде что она это прочитает"',
    '{"title": "Написать пост о Ленке", "description": "Написать в фейсбук про Ленку, намекая маме на свою ситуацию"}',
    '',
    'Вход: "Позвоню маме прямо сейчас и расскажу всю правду о том что произошло"',
    '{"title": "Позвонить маме", "description": "Позвонить маме и рассказать правду"}',
  );

  const aiResponse = await callAI({
    system: systemPrompt,
    messages: [
      {
        role: 'user',
        content: userPrompt,
      },
    ],
    temperature: 0.2, // Очень низкая температура для точного следования лимитам
    maxTokens: 300,
    signal,
    claudeApiKey,
    claudeProxyUrl,
    openAIApiKey,
    openAIProxyUrl,
    // Используем Claude (более точно следует инструкциям) вместо GPT-4o-mini
  });

  const { parsed } = parseJsonWithRecovery(aiResponse.text, 'HistoryStory:custom-option');

  const optionSource = (parsed as { title?: unknown; description?: unknown }) ?? {};

  const title =
    typeof optionSource.title === 'string' && optionSource.title.trim().length > 0
      ? clampString(enforceSingleLine(optionSource.title), 48)
      : clampString(enforceSingleLine(normalizedTranscript), 48);

  const description =
    typeof optionSource.description === 'string' && optionSource.description.trim().length > 0
      ? clampString(enforceSingleLine(optionSource.description), 140)
      : clampString(enforceSingleLine(normalizedTranscript), 140);

  const id = `custom-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

  return {
    id,
    title,
    description,
    kind: 'custom',
    transcript: normalizedTranscript,
    rawUserText: normalizedTranscript,
  };
}
