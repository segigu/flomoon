import { callAI, type AIMessage } from './aiClient';
import {
  ASTRO_PROFILES,
  PRIMARY_PROFILE_ID,
  type AstroProfile,
} from '../data/astroProfiles';
import {
  buildNatalChartAnalysis,
  type NatalChartAnalysis,
} from './astro';
import {
  findScenarioById,
  getFallbackContract,
  normalizePsychologicalContract,
  type PsychologicalContract,
  type ContractScenario,
} from '../data/psychologicalContracts';
import {
  getPsychContractHistorySnapshot,
  rememberContractUsage,
} from './psychContractHistory';
import {
  parseJsonWithRecovery,
  enforceSingleLine,
  clampString,
} from './promptPostprocessors';
import {
  NO_MYSTIC_RULES,
  EUROPE_CONTEXT_RULES,
  CHARACTER_NAME_RULES,
  STORY_CONTINUITY_RULES,
  STORY_STRUCTURE_POINTS,
  STORY_SCENE_REQUIREMENTS,
  CHOICE_REQUIREMENTS,
  JSON_FORMAT_RULES,
  RECENT_CONTRACT_RULES,
  buildMoonSummaryInstruction,
  FINALE_HUMAN_INTERPRETATION_RULES,
  FINALE_ASTRO_RULES,
  formatLifeSphereExamples,
  formatScenarioExamples,
} from '../data/storyGuidelines';

export interface HistoryStoryOption {
  id: string;
  title: string;
  description: string;
  /**
   * Indicates whether the option was generated by AI or proposed by the user.
   * Defaults to "ai" for backwards compatibility.
   */
  kind?: 'ai' | 'custom';
  /**
   * Raw transcript provided by the user (for custom options).
   */
  transcript?: string;
  /**
   * Any additional unformatted text that led to this option.
   */
  rawUserText?: string;
}

export interface HistoryStoryMeta {
  author: string;
  title: string;
  genre: string;
  contract: string;
  moonSummary: string; // Сообщение от Луны, подводящее итог диалога и объясняющее выбор темы
  arcLimit: number;
}

export interface HistoryStoryNodeInfo {
  arc: number;
  stage: string;
  scene: string;
}

export interface HistoryStoryFinale {
  resolution: string;
  humanInterpretation: string;
  astrologicalInterpretation: string;
}

export interface HistoryStoryResponse {
  meta?: HistoryStoryMeta;
  node?: HistoryStoryNodeInfo;
  options: HistoryStoryOption[];
  finale?: HistoryStoryFinale;
}

export interface HistoryStoryContextSegment {
  /**
   * Text that has already been shown to the user.
   */
  text: string;
  /**
   * Arc number associated with this segment.
   */
  arc: number;
  /**
   * Optional short title of the option that lead to this segment.
   */
  optionTitle?: string;
  /**
   * Optional explanation of the option that lead to this segment.
   */
  optionDescription?: string;
  /**
   * Raw transcript of the user's custom option (if any).
   */
  optionTranscript?: string;
  /**
   * Option origin.
   */
  optionKind?: 'ai' | 'custom';
}

export interface HistoryStoryAuthorStyle {
  name: string;
  stylePrompt: string;
  genre: string;
}

export interface HistoryStoryRequestOptions {
  /**
   * Previously generated story fragments, ordered chronologically.
   * The last element corresponds to the most recent paragraph.
   */
  segments: HistoryStoryContextSegment[];
  /**
   * Optional direction that the user выбрал для следующего шага.
   */
  currentChoice?: HistoryStoryOption;
  /**
   * Optional short summary of earlier events to reduce prompt length.
   */
  summary?: string;
  /**
   * Author persona that should narrate the story.
   */
  author: HistoryStoryAuthorStyle;
  /**
   * Total number of arcs expected in the story.
   */
  arcLimit: number;
  /**
   * Generation mode: either next arc or finale.
   */
  mode: 'arc' | 'finale';
  /**
   * Arc number that should be produced (required for arc mode).
   */
  currentArc?: number;
  /**
   * Previously established story contract, if any.
   */
  contract?: string;
  /**
   * Optional AbortSignal to cancel the AI request.
   */
  signal?: AbortSignal;
  /**
   * Optional Claude API key.
   */
  claudeApiKey?: string;
  /**
   * Optional Claude proxy URL.
   */
  claudeProxyUrl?: string;
  /**
   * Optional OpenAI API key for fallback.
   */
  openAIApiKey?: string;
  /**
   * Optional OpenAI proxy URL.
   */
  openAIProxyUrl?: string;
}

const STORY_STAGE_NAMES = [
  'Завязка',
  'Обострение',
  'Выбор',
  'Последствия',
  'Кульминация',
  'Поворотный момент',
] as const;

const STORY_STAGE_GUIDANCE: Record<string, string> = {
  Завязка: 'Покажи конкретную жизненную ситуацию, в которой проявляется внутренний конфликт. Обычная обстановка, реальные люди, понятная дилемма.',
  Обострение: 'Усиль давление: другие люди давят, обстоятельства требуют решения, время поджимает. Напряжение растёт.',
  Выбор: 'Героиня должна выбрать: пойти привычным путём (ловушка) или рискнуть попробовать по-другому.',
  Последствия: 'Покажи, что происходит после выбора. Реакции людей, собственные чувства, цена решения.',
  Кульминация: 'Самый острый момент: героиня сталкивается с главным страхом или болью этого конфликта.',
  'Поворотный момент': 'ВАЖНО: Это НЕ финал истории! Героиня делает ключевое действие или принимает решение, которое приведёт к развязке. Предпоследняя сцена перед финалом.',
};

const CONTEXT_LIMIT = 10; // Увеличено для лучшей связности истории (было 4)

const FALLBACK_OPTIONS: [HistoryStoryOption, HistoryStoryOption] = [
  {
    id: 'stand-ground',
    title: 'Сказать правду',
    description: 'Честно озвучить свои чувства и потребности, даже если это неудобно.',
    kind: 'ai',
  },
  {
    id: 'stay-quiet',
    title: 'Промолчать',
    description: 'Промолчать ради сохранения мира и избежания конфликта.',
    kind: 'ai',
  },
];

const DEFAULT_CONTRACT = 'Могу ли я защитить свои границы, не чувствуя себя плохим человеком?';

// DEFAULT константы удалены - fallback больше не используется для сохранения целостности истории

const NASTIA_PROFILE = ASTRO_PROFILES[PRIMARY_PROFILE_ID];
const NASTIA_CHART_ANALYSIS = buildNatalChartAnalysis(PRIMARY_PROFILE_ID);
const BIRTH_DATA_TEXT = serializeBirthData(NASTIA_PROFILE);
const CHART_ANALYSIS_TEXT = serializeChartAnalysis(NASTIA_CHART_ANALYSIS);

interface PsychContractContext {
  contract: PsychologicalContract;
  scenario?: ContractScenario;
}

let activePsychContext: PsychContractContext | undefined;

function serializeBirthData(profile: AstroProfile): string {
  const locationNote = profile.notes?.split('(')[0]?.trim() ?? 'Тикси, Россия';
  const time = profile.birthTime ?? '12:00';
  return `{
  "date": "${profile.birthDate}",
  "time": "${time}",
  "timezone": "${profile.timeZone}",
  "location": "${locationNote}",
  "latitude": ${profile.latitude},
  "longitude": ${profile.longitude}
}`;
}

function serializeChartAnalysis(analysis: NatalChartAnalysis): string {
  const formatSection = (label: string, values: string[]): string => {
    if (!values.length) {
      return `${label}: []`;
    }
    return `${label}:\n- ${values.join('\n- ')}`;
  };

  return [
    formatSection('core_placements', analysis.corePlacements),
    formatSection('hard_aspects', analysis.hardAspects),
    formatSection('soft_aspects', analysis.softAspects),
  ].join('\n');
}

function indent(text: string, spaces = 2): string {
  const pad = ' '.repeat(spaces);
  return text
    .split('\n')
    .map(line => (line.length ? pad + line : line))
    .join('\n');
}

function joinSections(...sections: Array<string | false | undefined>): string {
  return sections.filter(Boolean).join('\n\n');
}

function getStageName(arc: number, arcLimit: number): string {
  const index = Math.max(0, Math.min(STORY_STAGE_NAMES.length - 1, arc - 1));
  return STORY_STAGE_NAMES[index] ?? STORY_STAGE_NAMES[STORY_STAGE_NAMES.length - 1];
}

function getStageGuidance(stage: string): string {
  return STORY_STAGE_GUIDANCE[stage] ?? '';
}

function trimString(value: unknown): string {
  return typeof value === 'string' ? value.trim() : '';
}

/**
 * Умная замена переносов строк в JSON:
 * - Находит все строковые значения в JSON (между кавычками)
 * - Заменяет переносы строк внутри этих значений на пробелы
 * - Оставляет структурные элементы JSON (запятые, скобки) без изменений
 */
async function generatePsychContractContext(
  claudeApiKey?: string,
  claudeProxyUrl?: string,
  openAIApiKey?: string,
  openAIProxyUrl?: string,
): Promise<PsychContractContext> {
  const historySnapshot = getPsychContractHistorySnapshot();
  const recentContractIds = historySnapshot.contracts.slice(0, 8).map(entry => entry.id);
  const recentScenarios = historySnapshot.scenarios.slice(0, 12).map(
    entry => `${entry.contractId}/${entry.scenarioId}`,
  );
  const diversifiedContractsBlockLines = RECENT_CONTRACT_RULES.split('\n');
  const diversifiedContractsBlock = [
    `6. ${diversifiedContractsBlockLines[0]}`,
    ...diversifiedContractsBlockLines.slice(1).map(line => `   ${line}`),
  ].join('\n');
  const lifeSphereExamples = formatLifeSphereExamples();
  const scenarioExamples = formatScenarioExamples();

  const prompt = joinSections(
    'Ты — психолог и драматургка, создающая интерактивные истории о внутреннем конфликте.',
    'Тебе нужно придумать свежий психологический контракт для Насти. Опираться надо на её натальную карту и избегать повторов прошлых контрактов/сцен.',
    `🔹 ДАННЫЕ
birth_data:
${indent(BIRTH_DATA_TEXT, 2)}
chart_analysis:
${indent(CHART_ANALYSIS_TEXT, 2)}
recent_contract_ids: ${JSON.stringify(recentContractIds)}
recent_scenarios: ${JSON.stringify(recentScenarios)}`,
    `🔹 ЗАДАНИЕ
1. Осмысли психологическое напряжение карты и предложи НОВЫЙ внутренний конфликт (контракт).
2. Контракт должен быть простым, понятным вопросом из жизни — БЕЗ метафор и сложных формулировок.
3. Опиши 3 ловушки поведения (механизмы защиты, самообман).
4. Придумай 3 РЕАЛЬНЫЕ ЖИЗНЕННЫЕ СИТУАЦИИ (не мистику!).
   - ЗАПРЕЩЕНО: пустые метро, заброшенные дома, крыши, тёмные леса, замёрзшие озёра, любая мистика
   - НУЖНО: офис, квартира, кафе, парк, дом родителей, встреча с друзьями — обычные места
5. Добавь 3 ключевые точки выбора — конкретные жизненные дилеммы.
${diversifiedContractsBlock}
7. Чередуй 9 сфер жизни: работа, любовь, дружба, семья, саморазвитие, хобби, здоровье, финансы, творчество
8. Конкретные примеры контрактов по сферам:
${lifeSphereExamples}
9. ПРОВЕРЬ СЕБЯ: если твой контракт похож на что-то из recent_contract_ids — начни заново с другой сферы.`,
    `🔹 ПРИМЕРЫ СЦЕНАРИЕВ
${scenarioExamples}`,
    `🔹 ТРЕБОВАНИЯ К СТРУКТУРЕ
- contract.id — уникальный kebab-case латиницей без пробелов (например: career-vs-family).
- contract.question — простой понятный вопрос БЕЗ метафор (например: "Могу ли я отказать маме, если это важно для меня?").
- contract.theme — одно-два простых слова из жизни.
- contract.astroIndicators — 3–4 маркера (текстом, можно на русском).
- contract.commonTraps — массив из трёх объектов { "name": "...", "description": "..." }.
- contract.scenarios — массив из трёх РЕАЛЬНЫХ жизненных ситуаций { "id": "kebab-case", "setting": "ОБЫЧНОЕ МЕСТО (офис/кафе/дом)", "situation": "КОНКРЕТНАЯ ЖИЗНЕННАЯ СИТУАЦИЯ", "symbolism": "краткий смысл" }.
- contract.choicePoints — массив из трёх СТРОК (НЕ объектов!) с конкретными жизненными выборами. Пример: ["Остаться на работе или поехать в отпуск?", "Помочь подруге или отказать?", "Ответить на сообщение или игнорировать?"]
- recommendedScenarioId — id сцены, с которой лучше начать историю.
- Используй русский для описаний, но id оставь латиницей.`,
    `🔹 ФОРМАТ ОТВЕТА (JSON без форматирования, без комментариев):
{
  "contract": { ...см. выше... },
  "recommendedScenarioId": "scenario-id"
}`,
    JSON_FORMAT_RULES,
    'Не добавляй пояснений, текста вне JSON и Markdown.',
  );

  try {
    const result = await callAI({
      system:
        'Ты психологический архитектор историй. Придумывай новые конфликты, избегай повторов и отвечай только JSON.',
      messages: [
        {
          role: 'user',
          content: prompt,
        },
      ],
      temperature: 0.85,
      maxTokens: 2500,
      claudeApiKey,
      claudeProxyUrl,
      openAIApiKey,
      openAIProxyUrl,
    });

    const { parsed } = parseJsonWithRecovery<any>(result.text, 'PsychContract');

    console.log('[PsychContract] Parsed response:', JSON.stringify(parsed, null, 2));

    const contract = normalizePsychologicalContract(parsed?.contract ?? parsed);
    if (!contract) {
      console.error('[PsychContract] Failed to normalize contract. Raw data:', parsed);
      throw new Error('Модель вернула некорректный контракт');
    }

    console.log('[PsychContract] ✅ Contract validated:', contract.id, contract.question);

    const recommendedScenarioId = trimString(
      parsed?.recommendedScenarioId ?? parsed?.recommended_scenario_id ?? '',
    );
    const scenario = findScenarioById(contract, recommendedScenarioId);

    rememberContractUsage(contract.id, scenario.id);

    return {
      contract,
      scenario,
    };
  } catch (error) {
    console.warn('[PsychContract] Failed to generate via AI, using fallback', error);
    const fallback = getFallbackContract(recentContractIds, recentScenarios);
    const fallbackScenario = findScenarioById(
      fallback.contract,
      fallback.recommendedScenarioId,
    );
    rememberContractUsage(fallback.contract.id, fallbackScenario.id);
    return {
      contract: fallback.contract,
      scenario: fallbackScenario,
    };
  }
}

async function ensurePsychContractContext(
  claudeApiKey?: string,
  claudeProxyUrl?: string,
  openAIApiKey?: string,
  openAIProxyUrl?: string,
): Promise<PsychContractContext> {
  if (activePsychContext) {
    return activePsychContext;
  }

  activePsychContext = await generatePsychContractContext(
    claudeApiKey,
    claudeProxyUrl,
    openAIApiKey,
    openAIProxyUrl,
  );
  return activePsychContext;
}

export function clearPsychContractContext(): void {
  activePsychContext = undefined;
}

function buildPsychologicalContractInfo(
  contract?: PsychologicalContract,
  scenario?: ContractScenario,
): string {
  if (!contract) {
    return '';
  }

  const trapsText = contract.commonTraps
    .map(trap => `• ${trap.name}: ${trap.description}`)
    .join('\n');

  const scenarioText = scenario
    ? `Рекомендуемый сценарий:
- Обстановка: ${scenario.setting}
- Ситуация: ${scenario.situation}
- Символизм: ${scenario.symbolism}`
    : '';

  return `
🔹 ПСИХОЛОГИЧЕСКИЙ КОНТРАКТ

Основной вопрос: «${contract.question}»
Тема: ${contract.theme}

Типичные психологические ловушки:
${trapsText}

Ключевые точки выбора:
${contract.choicePoints.map(point => `• ${point}`).join('\n')}

${scenarioText}

ВАЖНО: На каждом этапе истории проверяй, не попадает ли героиня в одну из ловушек.
Выборы должны раскрывать эти ловушки и давать возможность увидеть паттерн.`;
}

function buildStorySoFar(
  segments: HistoryStoryContextSegment[],
  arcLimit: number,
  summary?: string,
): string {
  if (!segments.length) {
    return 'История ещё не началась.';
  }

  const recentSegments = segments.slice(-CONTEXT_LIMIT);

  const parts = recentSegments.map((segment, index) => {
    const stage = getStageName(segment.arc, arcLimit);
    const choiceDetails: string[] = [];
    if (segment.optionTitle) {
      const base = `>>> Выбор, который привёл к этой сцене: «${segment.optionTitle}»`;
      const withDescription = segment.optionDescription
        ? `${base} — ${segment.optionDescription}`
        : base;
      choiceDetails.push(withDescription);
    } else {
      choiceDetails.push('>>> Начальная сцена');
    }

    if (segment.optionTranscript && segment.optionTranscript.trim().length > 0) {
      choiceDetails.push(`>>> Дословно Настя сказала: "${segment.optionTranscript.trim()}"`);
    }

    const choiceLine = choiceDetails.join('\n');
    const sceneLabel = `[Сцена ${segment.arc}/${arcLimit}: ${stage}]`;
    return `${sceneLabel}\n${choiceLine}\n${segment.text}`;
  });

  if (summary && summary.trim().length > 0) {
    return `${summary.trim()}\n\n${parts.join('\n\n')}`;
  }

  return parts.join('\n\n');
}

function buildInputDataBlock(genre: string, arcLimit: number): string {
  return `🔹 ВХОДНЫЕ ДАННЫЕ

user_name: ${NASTIA_PROFILE.name}
birth_data:
${indent(BIRTH_DATA_TEXT, 2)}
chart_analysis:
${indent(CHART_ANALYSIS_TEXT, 2)}
story_genre: ${genre}
arc_limit: ${arcLimit}
language: ru`;
}

interface ArcPromptArgs {
  segments: HistoryStoryContextSegment[];
  currentChoice?: HistoryStoryOption;
  summary?: string;
  author: HistoryStoryAuthorStyle;
  arcLimit: number;
  currentArc: number;
  contract?: string;
}

function buildArcPrompt(args: ArcPromptArgs, psychContext?: PsychContractContext): string {
  const {
    segments,
    currentChoice,
    summary,
    author,
    arcLimit,
    currentArc,
    contract,
  } = args;

  const stage = getStageName(currentArc, arcLimit);
  const stageGuidance = getStageGuidance(stage);
  const storyContext = buildStorySoFar(segments, arcLimit, summary);

  const hasCustomChoice = currentChoice?.kind === 'custom' && currentChoice.transcript;
  const transcriptNote = hasCustomChoice && currentChoice?.transcript
    ? `

⚠️⚠️⚠️ ЭТО ГОЛОСОВОЙ ВАРИАНТ ПОЛЬЗОВАТЕЛЯ — СЛЕДУЙ ЕМУ БУКВАЛЬНО! ⚠️⚠️⚠️

Пользователь СКАЗАЛ СВОИМИ СЛОВАМИ: "${currentChoice.transcript.trim()}"

КРИТИЧЕСКИ ВАЖНО - ПОКАЖИ МОМЕНТ ДЕЙСТВИЯ:
1. Если названо ДЕЙСТВИЕ (попросить, позвонить, сказать, пойти) — покажи КАК это происходит ПРЯМО СЕЙЧАС, а НЕ результат после
2. Если названы ИМЕНА (Лена, Ленка, мама) — используй ТОЧНО ЭТИ имена, не заменяй на "подруга", "близкие"
3. Если названы МЕСТА (офис, кафе, дом) — действие происходит ИМЕННО ТАМ
4. НЕ пиши "После того как..." или "Ты уже..." — покажи действие В ПРОЦЕССЕ

КРИТИЧЕСКАЯ ОШИБКА, КОТОРУЮ ТЫ ДЕЛАЕШЬ:
❌ "Попросить у Лены в долг" → НЕ ПИШИ: "После разговора с Леной ты стоишь..."
✅ "Попросить у Лены в долг" → ПРАВИЛЬНО: "Ты подходишь к Лене. 'Лен, можешь одолжить мне денег на платье? Верну через пару месяцев.' Она останавливается, смотрит на тебя..."

❌ "Позвонить маме" → НЕ ПИШИ: "После звонка маме ты чувствуешь..."
✅ "Позвонить маме" → ПРАВИЛЬНО: "Ты набираешь номер. — Мам, привет... — начинаешь ты. — Солнышко! — мамин голос теплый..."

❌ "Пойти к Лее обсудить" → НЕ ПИШИ: "Ты решила поговорить с подругой..."
✅ "Пойти к Лее обсудить" → ПРАВИЛЬНО: "Ты идёшь к Лее. Она открывает дверь. — Привет, что случилось? — видя твоё лицо, она сразу понимает..."

ПОМНИ: Сцена начинается С НАЧАЛА действия, которое назвал пользователь, а не после его завершения!`
    : currentChoice?.transcript
      ? `
Пользователь произнёс: "${currentChoice.transcript.trim()}". Все ключевые детали из этой фразы должны явно отразиться в сцене.`
      : '';

  const choiceInstruction = currentChoice
    ? `КРИТИЧЕСКИ ВАЖНО: Это продолжение ОДНОЙ истории!
Предыдущий выбор Насти: «${currentChoice.title}»${currentChoice.description ? ` (${currentChoice.description})` : ''}.${transcriptNote}
Новая сцена должна быть ПРЯМЫМ ПОСЛЕДСТВИЕМ этого выбора.
Покажи, что произошло ПОСЛЕ того, как она сделала этот выбор.
Сохраняй всех персонажей, место действия и ситуацию из предыдущих сцен.
НЕЛЬЗЯ обнулять выбор, менять его на противоположный или игнорировать последствия.`
    : 'Это первый узел — начинай сразу с конкретной ситуации, как описано в рекомендуемом сценарии.';

  const psychContract = psychContext?.contract;
  const psychScenario = currentArc === 1 ? psychContext?.scenario : undefined;

  const contractInstruction = contract
    ? `Контракт истории уже задан: «${contract}». Сохраняй формулировку без изменений и напоминай себе о нём при создании сцен.`
    : psychContract
      ? `Контракт истории: «${psychContract.question}». Используй этот контракт на всех узлах без изменений.`
      : 'Контракт истории будет задан автоматически.';

  const stageSection = joinSections(
    `Сейчас нужно создать узел ${currentArc} из ${arcLimit} — «${stage}».`,
    currentArc === arcLimit
      ? `⚠️ ВАЖНО: Это узел ${currentArc}, НО ЭТО ЕЩЁ НЕ ФИНАЛ истории!
После этого узла будет ещё отдельный финальный блок с развязкой и интерпретацией.
Твоя задача здесь: создать предпоследнюю сцену и дать героине ПОСЛЕДНИЙ выбор.
НЕ завершай историю, НЕ пиши развязку — только ещё одну сцену с выбором!`
      : undefined,
    `Фокус этого узла: ${stageGuidance}`,
    currentArc === 1 && psychScenario
      ? 'ОБЯЗАТЕЛЬНО используй рекомендуемый сценарий (см. выше в блоке "Психологический контракт"). Создай сцену на основе указанной обстановки и ситуации — это РЕАЛЬНОЕ место, РЕАЛЬНАЯ ситуация.'
      : undefined,
    choiceInstruction,
    contractInstruction,
  );

  const storyContextSection = `Контекст истории (прочитай ВНИМАТЕЛЬНО, это уже произошедшие события):
${storyContext}`;

  const continuationSection =
    currentArc > 1
      ? `ИНСТРУКЦИЯ ПО ПРОДОЛЖЕНИЮ:
1. Перечитай ВСЕ предыдущие сцены выше
2. Найди имена персонажей, место действия, ключевые фразы
3. Твоя новая сцена начинается сразу после последнего выбора
4. Используй те же имена, если персонажи названы
5. Покажи прямую причинно-следственную связь: выбор → последствие
6. Если герой выбрал "сказать правду", покажи КАК он это сказал и что ответили
7. Если герой выбрал "промолчать", покажи КАК он промолчал и что из этого вышло`
      : undefined;

  const moonSummaryInstruction = buildMoonSummaryInstruction().replace(/"/g, '\\"');
  const metaLines: string[] = [
    `    "author": "${author.name}"`,
    '    "title": "Краткое название истории (2-3 слова, отражающих суть контракта)"',
    '    "genre": "реализм"',
    '    "contract": "строка"',
  ];
  if (currentArc === 1) {
    metaLines.push(`    "moon_summary": "${moonSummaryInstruction}"`);
  }
  metaLines.push(`    "arc_limit": ${arcLimit}`);

  const jsonExample = `Ответь строго в формате JSON:
{
  "meta": {
${metaLines.join(',\n')}
  },
  "node": {
    "arc": ${currentArc},
    "stage": "${stage}",
    "scene": "абзац истории"
  },
  "choices": [
    { "id": "уникальный-kebab-case", "title": "…", "description": "…" },
    { "id": "уникальный-kebab-case", "title": "…", "description": "…" }
  ]
}`;

  const sections: Array<string | false | undefined> = [
    buildInputDataBlock(author.genre, arcLimit),
    psychContract ? buildPsychologicalContractInfo(psychContract, psychScenario) : undefined,
    '🔹 ПРОМПТ (ядро для модели)',
    'Создай персональную интерактивную историю о реальной жизненной ситуации.',
    `Основывай тему и конфликт на ключевых аспектах натальной карты пользователя Насти:
chart_analysis подключён выше — используй соответствующие мотивы и напряжения.`,
    `Авторский стиль: ${author.stylePrompt}`,
    'Героиня — женщина, имя не упоминается.',
    'Повествование ведётся от второго лица («ты»).',
    psychContract
      ? `История раскрывает психологический контракт: «${psychContract.question}». На каждом этапе показывай, как героиня сталкивается с типичными ловушками этого контракта (см. выше).`
      : undefined,
    NO_MYSTIC_RULES,
    EUROPE_CONTEXT_RULES,
    CHARACTER_NAME_RULES,
    STORY_CONTINUITY_RULES,
    `Структура истории:\n${STORY_STRUCTURE_POINTS.join('\n')}`,
    stageSection,
    storyContextSection,
    continuationSection,
    STORY_SCENE_REQUIREMENTS,
    CHOICE_REQUIREMENTS,
    jsonExample,
    JSON_FORMAT_RULES,
    'Не добавляй пояснений, комментариев, Markdown и эмодзи.',
  ];

  return joinSections(...sections);
}

interface FinalePromptArgs {
  segments: HistoryStoryContextSegment[];
  currentChoice?: HistoryStoryOption;
  summary?: string;
  author: HistoryStoryAuthorStyle;
  arcLimit: number;
  contract?: string;
}

function buildFinalePrompt(args: FinalePromptArgs, psychContext?: PsychContractContext): string {
  const {
    segments,
    currentChoice,
    summary,
    author,
    arcLimit,
    contract,
  } = args;

  const storyContext = buildStorySoFar(segments, arcLimit, summary);

  const hasCustomFinaleChoice = currentChoice?.kind === 'custom' && currentChoice.transcript;
  const finaleTranscriptNote = hasCustomFinaleChoice && currentChoice?.transcript
    ? `

⚠️⚠️⚠️ ФИНАЛЬНЫЙ ВЫБОР — ГОЛОСОВОЙ ВАРИАНТ ПОЛЬЗОВАТЕЛЯ! ⚠️⚠️⚠️

Настя СКАЗАЛА СВОИМИ СЛОВАМИ: "${currentChoice.transcript.trim()}"

КРИТИЧЕСКИ ВАЖНО - ПОКАЖИ МОМЕНТ ДЕЙСТВИЯ В РАЗВЯЗКЕ:
1. Покажи КАК происходит действие, а НЕ "после того как"
2. Используй ТОЧНЫЕ имена/места из голоса (Лена/Ленка = "Лена", не "подруга")
3. НЕ обобщай действие ("попросить в долг" ≠ "обратиться за помощью")
4. Развязка НАЧИНАЕТСЯ с этого действия, показывает его процесс и последствия

КРИТИЧЕСКАЯ ОШИБКА:
❌ "Попросить у Лены в долг" → НЕ ПИШИ: "После разговора с Леной ты поняла..."
✅ "Попросить у Лены в долг" → ПРАВИЛЬНО: "Ты подошла к Лене. 'Лен, можешь одолжить денег на платье?' Она посмотрела на тебя, помолчала секунду... 'Знаешь, у меня сейчас самой туго...' И ты вдруг почувствовала облегчение..."

❌ "Позвонить маме" → НЕ ПИШИ: "Ты обратилась за поддержкой к близким..."
✅ "Позвонить маме" → ПРАВИЛЬНО: "Ты позвонила маме. — Мам, мне нужен совет... — Услышав твой голос, она сразу поняла..."`
    : currentChoice?.transcript
      ? ` Настя сказала буквально: "${currentChoice.transcript.trim()}" — развязка должна учитывать именно это.`
      : '';

  const choiceInstruction = currentChoice
    ? `Это итоговый выбор Насти: «${currentChoice.title}»${
        currentChoice.description ? ` (${currentChoice.description})` : ''
      }. Построй развязку как прямое последствие этого шага.${finaleTranscriptNote}`
    : 'Считай, что итоговый выбор сделан в пользу ясности — покажи последствия.';

  const contractInstruction = contract
    ? `Контракт истории: «${contract}». Придерживайся его тона в развязке.`
    : 'Сформулированный тобой контракт должен проявиться в выводах финала.';

  const finaleRealismRules = `ВАЖНО: Финал должен быть РЕАЛИСТИЧНЫМ и ЖИЗНЕННЫМ:
- НИКАКОЙ мистики, метафор, символов
- Покажи конкретную реакцию героини и окружающих
- Опиши реальные чувства и мысли
- Конкретные действия, а не абстракции`;

  const finaleBlockSection = joinSections(
    'Сформируй финальный блок:',
    '- resolution — один абзац из 3–5 предложений (60–90 слов), который завершает сюжет через КОНКРЕТНЫЕ действия и слова, показывает последствия выбора и закрывает напряжение;',
    FINALE_HUMAN_INTERPRETATION_RULES,
    '',
    'ВАЖНО ДЛЯ human_interpretation: Используй здоровый сарказм и юмор! Если выборы были странными или не по теме контракта — скажи об этом прямо с иронией.',
    '',
    `Пример human_interpretation (обычный случай): "Твой выбор спрятаться на первом этапе — классическая осторожность, тут всё понятно. Но третий этап... Секунду, ты вдруг решила 'пойду смело навстречу'? После пяти сцен избегания? Либо внутренний герой проснулся, либо ты просто нажала не ту кнопку. На пятом этапе вернулась к привычной схеме 'лучше промолчу' — вот она, настоящая реакция. Интересно: где тут ты настоящая, а где играешь в смелую?"`,
    '',
    `Пример human_interpretation (абсурдные выборы): "Погоди... Контракт был про страх отказа маме, а ты на втором этапе решила написать пост в фейсбук про подругу Ленку? Это вообще о чём? Потом взяла деньги в долг у той же Ленки, потом призналась ей о парне... Окей, ты явно экспериментировала или проверяла, что будет. История про отношения с мамой куда-то уехала на второй план. Либо ты мастерски избегаешь настоящей темы, либо просто баловалась. Честно — похоже на второе."`,
    FINALE_ASTRO_RULES,
    `Пример формулировки: "Твой выбор уйти в тень на первом этапе логично объясняется Луной в 12-м доме (потребность в уединении и защите). Квадрат Сатурна к Луне добавил страха перед ошибкой. Но на третьем этапе ты резко выбрала 'пойти смело вперёд' — это ПРОТИВОРЕЧИТ и осторожной Луне, и медлительному Марсу в Тельце. У тебя нет импульсивных аспектов (Уран, Марс в огне), которые объясняли бы такой выбор. Возможно, ты выбрала не то, что чувствуешь, а то, что считаешь 'правильным' — социально одобряемую смелость вместо честной осторожности. На пятом этапе ты вернулась к паттерну Сатурна-Луны (контроль и защита) — вот она, настоящая реакция. Карта не врёт: твоя природа — это вдумчивость, не импульс."`,
    'Сохраняй второе лицо и атмосферность, не добавляй новых развилок.',
  );

  const finaleJsonExample = `Ответь строго в формате JSON (пример):
{"meta":{"author":"${author.name}","title":"Краткое название истории (2-3 слова)","genre":"реализм","contract":"строка","arc_limit":${arcLimit}},"finale":{"resolution":"абзац-развязка в одну непрерывную строку с пробелами вместо переносов","human_interpretation":"4-6 предложений в одну непрерывную строку: анализ выборов через черты характера, без астрологических терминов","astrological_interpretation":"4-7 предложений в одну непрерывную строку: детальный астрологический анализ выборов с планетами, домами и аспектами"}}`;

  const sections: Array<string | false | undefined> = [
    buildInputDataBlock(author.genre, arcLimit),
    psychContext ? `${buildPsychologicalContractInfo(psychContext.contract)}\n` : undefined,
    '🔹 ПРОМПТ (ядро для модели)',
    'Ты завершишь интерактивную историю для Насти.',
    contractInstruction,
    choiceInstruction,
    `Удерживай авторский стиль: ${author.stylePrompt}`,
    finaleRealismRules,
    EUROPE_CONTEXT_RULES,
    CHARACTER_NAME_RULES,
    STORY_CONTINUITY_RULES,
    `Контекст истории:\n${storyContext}`,
    finaleBlockSection,
    finaleJsonExample,
    JSON_FORMAT_RULES,
    'Никаких пояснений, только компактный JSON в одну строку или с минимальными переносами между полями (но не внутри строковых значений).',
  ];

  return joinSections(...sections);
}

function sanitizeOption(
  option: Partial<HistoryStoryOption> | undefined,
  fallback: HistoryStoryOption,
): HistoryStoryOption {
  if (!option) {
    return fallback;
  }

  const id = typeof option.id === 'string' && option.id.trim().length > 0
    ? option.id.trim()
    : fallback.id;

  const title = typeof option.title === 'string' && option.title.trim().length > 0
    ? clampString(enforceSingleLine(option.title), 48)
    : fallback.title;

  const description = typeof option.description === 'string' && option.description.trim().length > 0
    ? clampString(enforceSingleLine(option.description), 140)
    : fallback.description;

  return {
    id,
    title,
    description,
    kind: 'ai',
  };
}

interface NormalizeOptions {
  mode: 'arc' | 'finale';
  authorName: string;
  genre: string;
  arcLimit: number;
  currentArc: number;
  contract?: string;
}

export function normalizeResponse(raw: unknown, options: NormalizeOptions): HistoryStoryResponse {
  const contract = options.contract ?? DEFAULT_CONTRACT;

  if (options.mode === 'finale') {
    const metaSource = (raw as any)?.meta;
    const finaleSource = (raw as any)?.finale ?? raw;

    const resolvedContract =
      typeof metaSource?.contract === 'string' && metaSource.contract.trim().length > 0
        ? metaSource.contract.trim()
        : contract;

    const resolution =
      typeof finaleSource?.resolution === 'string' && finaleSource.resolution.trim().length > 0
        ? finaleSource.resolution.trim()
        : '';

    const humanInterpretation =
      typeof finaleSource?.human_interpretation === 'string' && finaleSource.human_interpretation.trim().length > 0
        ? finaleSource.human_interpretation.trim()
        : typeof finaleSource?.interpretation === 'string' && finaleSource.interpretation.trim().length > 0
          ? finaleSource.interpretation.trim()
          : '';

    const astrologicalInterpretation =
      typeof finaleSource?.astrological_interpretation === 'string' && finaleSource.astrological_interpretation.trim().length > 0
        ? finaleSource.astrological_interpretation.trim()
        : '';

    // Проверяем, что все части финала заполнены
    if (!resolution) {
      throw new Error('История замерла в предвкушении... 🎭 Попробуем снова?');
    }
    if (!humanInterpretation) {
      throw new Error('Психолог задумался слишком глубоко 🤔 Ещё разок?');
    }
    if (!astrologicalInterpretation) {
      throw new Error('Планеты выстроились в очередь за кофе ☕✨ Нажми "Попробовать снова"!');
    }

    return {
      meta: {
        author: typeof metaSource?.author === 'string' && metaSource.author.trim().length > 0
          ? metaSource.author.trim()
          : options.authorName,
        title: typeof metaSource?.title === 'string' && metaSource.title.trim().length > 0
          ? metaSource.title.trim()
          : 'Без названия',
        genre: 'реализм', // Всегда реализм, игнорируем ответ AI
        contract: resolvedContract,
        moonSummary: '', // Для finale не используется
        arcLimit: Number.isFinite(metaSource?.arc_limit)
          ? Number(metaSource.arc_limit)
          : options.arcLimit,
      },
      options: [],
      finale: {
        resolution,
        humanInterpretation,
        astrologicalInterpretation,
      },
    };
  }

  const metaSource = (raw as any)?.meta ?? (raw as any);
  const nodeSource = (raw as any)?.node ?? (raw as any);
  // Ищем choices внутри node или на верхнем уровне (для обратной совместимости)
  const choicesSource = Array.isArray(nodeSource?.choices)
    ? nodeSource.choices
    : Array.isArray(nodeSource?.options)
      ? nodeSource.options
      : Array.isArray((raw as any)?.choices)
        ? (raw as any).choices
        : Array.isArray((raw as any)?.options)
          ? (raw as any).options
          : [];

  const resolvedContract =
    typeof metaSource?.contract === 'string' && metaSource.contract.trim().length > 0
      ? metaSource.contract.trim()
      : contract;

  const rawMoonSummary =
    typeof metaSource?.moon_summary === 'string' ? enforceSingleLine(metaSource.moon_summary).trim() : '';
  const rawScene = typeof nodeSource?.scene === 'string' ? nodeSource.scene.trim() : '';
  const sceneText = rawScene ? enforceSingleLine(rawScene) : '';

  // Проверяем, что сцена не пустая
  if (!sceneText) {
    throw new Error('Сцена застряла между реальностями 🌀 Давай вытащим её обратно?');
  }

  const stageName =
    typeof nodeSource?.stage === 'string' && nodeSource.stage.trim().length > 0
      ? nodeSource.stage.trim()
      : getStageName(options.currentArc, options.arcLimit);

  const arcNumber = Number.isFinite(nodeSource?.arc)
    ? Math.max(1, Number(nodeSource.arc))
    : options.currentArc;

  // Проверяем, что есть хотя бы 2 опции
  if (!Array.isArray(choicesSource) || choicesSource.length < 2) {
    throw new Error('Развилка дорог потерялась в тумане 🌫️ Попробуем найти её снова?');
  }

  const normalizedOptions: HistoryStoryOption[] = [
    sanitizeOption(choicesSource[0], FALLBACK_OPTIONS[0]),
    sanitizeOption(choicesSource[1], FALLBACK_OPTIONS[1]),
  ];

  return {
    meta: {
      author: typeof metaSource?.author === 'string' && metaSource.author.trim().length > 0
        ? metaSource.author.trim()
        : options.authorName,
      title: typeof metaSource?.title === 'string' && metaSource.title.trim().length > 0
        ? enforceSingleLine(metaSource.title)
        : 'Без названия',
      genre: 'реализм', // Всегда реализм, игнорируем ответ AI
      contract: resolvedContract,
      moonSummary: rawMoonSummary.length > 0
        ? rawMoonSummary
        : '', // Пустая строка, если не первая дуга или не предоставлено
      arcLimit: Number.isFinite(metaSource?.arc_limit)
        ? Number(metaSource.arc_limit)
        : options.arcLimit,
    },
    node: {
      arc: arcNumber,
      stage: stageName,
      scene: sceneText,
    },
    options: normalizedOptions,
  };
}

export async function generateHistoryStoryChunk({
  segments,
  currentChoice,
  summary,
  author,
  arcLimit,
  mode,
  currentArc,
  contract,
  signal,
  claudeApiKey,
  claudeProxyUrl,
  openAIApiKey,
  openAIProxyUrl,
}: HistoryStoryRequestOptions): Promise<HistoryStoryResponse> {
  const targetArc = mode === 'arc' ? (currentArc ?? 1) : arcLimit;
  let resolvedContract = contract;
  let psychContext: PsychContractContext | undefined;

  if (mode === 'arc') {
    if (targetArc === 1 && !contract) {
      psychContext = await ensurePsychContractContext(
        claudeApiKey,
        claudeProxyUrl,
        openAIApiKey,
        openAIProxyUrl,
      );
      resolvedContract = psychContext.contract.question;
    } else if (activePsychContext) {
      psychContext = activePsychContext;
      if (!resolvedContract) {
        resolvedContract = psychContext.contract.question;
      }
    }
  } else if (mode === 'finale' && activePsychContext) {
    psychContext = activePsychContext;
    if (!resolvedContract) {
      resolvedContract = psychContext.contract.question;
    }
  }

  const prompt =
    mode === 'finale'
      ? buildFinalePrompt(
          {
            segments,
            currentChoice,
            summary,
            author,
            arcLimit,
            contract: resolvedContract,
          },
          psychContext,
        )
      : buildArcPrompt(
          {
            segments,
            currentChoice,
            summary,
            author,
            arcLimit,
            currentArc: targetArc,
            contract: resolvedContract,
          },
          psychContext,
        );

  const messages: AIMessage[] = [
    {
      role: 'user',
      content: prompt,
    },
  ];

  const hasCustomChoiceForGeneration = currentChoice?.kind === 'custom' && currentChoice?.transcript;
  const systemPromptSuffix = hasCustomChoiceForGeneration
    ? `

🚨🚨🚨 ГОЛОСОВОЙ ВАРИАНТ ПОЛЬЗОВАТЕЛЯ - ОСОБЫЕ ПРАВИЛА! 🚨🚨🚨

Пользователь сказал свой вариант голосом. В промпте ты увидишь его дословный текст.

ОБЯЗАТЕЛЬНО:
1. Покажи МОМЕНТ действия, а не результат: если сказано "попросить у Лены в долг" — покажи КАК она просит ("Ты подходишь к Лене: 'Лен, можешь одолжить мне денег?'"), а НЕ "после того как попросила"
2. Используй ТОЧНЫЕ имена из голоса: если сказано "Ленка" или "Лена" — используй ЭТО имя, не "подруга" или "коллега"
3. НЕ пропускай действие: если сказано "позвонить маме" — покажи звонок с диалогом, не "после звонка"
4. НЕ обобщай: "попросить в долг" ≠ "обратиться за помощью"

❌ НЕПРАВИЛЬНО: "После разговора с Леной ты стоишь..."
✅ ПРАВИЛЬНО: "Ты подходишь к Лене. 'Лен, можешь одолжить мне денег на платье?' — она смотрит на тебя удивленно..."

Соблюдай формат JSON без Markdown и СТРОГО следуй голосовому варианту.`
    : `

Соблюдай формат JSON без Markdown и выполняй все требования пользователя.`;

  try {
    const result = await callAI({
      system: `Ты ${author.name}, русскоязычная писательница, создающая ОДНУ связную интерактивную историю во втором лице для Насти.

КРИТИЧЕСКИ ВАЖНО:
- Это ОДНА история, которая развивается от начала до конца
- Каждая новая сцена — прямое продолжение предыдущей
- Сохраняй всех персонажей, их имена, характеры, сказанные фразы
- Показывай прямые последствия выборов пользователя
- Не начинай новую историю — продолжай существующую${systemPromptSuffix}`,
      messages,
      temperature: hasCustomChoiceForGeneration ? 0.5 : 0.85, // Снижаем temperature для голосовых вариантов
      maxTokens: mode === 'finale' ? 2000 : 1000, // Увеличено с 600 до 1000 для arc из-за более детальных промптов
      signal,
      claudeApiKey,
      claudeProxyUrl,
      openAIApiKey,
      openAIProxyUrl,
      // preferOpenAI не указываем - по умолчанию используется Claude первым
    });

    console.log(`[HistoryStory] Generated ${mode} using ${result.provider}`);

    const { parsed } = parseJsonWithRecovery(result.text, `HistoryStory:${mode}`);

    return normalizeResponse(parsed, {
      mode,
      authorName: author.name,
      genre: author.genre,
      arcLimit,
      currentArc: targetArc,
      contract: resolvedContract,
    });
  } catch (error) {
    if (error instanceof DOMException && error.name === 'AbortError') {
      throw error;
    }
    console.error(`[HistoryStory] Failed to generate ${mode}`, error);

    // НЕ используем fallback ни для finale, ни для arc
    // Fallback-сцены нарушают целостность истории
    if (mode === 'finale') {
      throw new Error('Звёзды отвлеклись на кофе-брейк 🌟☕ Давай попробуем ещё раз?');
    } else {
      throw new Error('Муза сбежала за вдохновением 🦋 Нажми "Попробовать снова" — она вернётся!');
    }
  }
}

export interface CustomHistoryOptionRequest {
  transcript: string;
  segments: HistoryStoryContextSegment[];
  summary?: string;
  author: HistoryStoryAuthorStyle;
  signal?: AbortSignal;
  claudeApiKey?: string;
  claudeProxyUrl?: string;
  openAIApiKey?: string;
  openAIProxyUrl?: string;
}

const MIN_TRANSCRIPT_WORDS = 3;

export async function generateCustomHistoryOption({
  transcript,
  segments,
  summary,
  author,
  signal,
  claudeApiKey,
  claudeProxyUrl,
  openAIApiKey,
  openAIProxyUrl,
}: CustomHistoryOptionRequest): Promise<HistoryStoryOption> {
  const cleanedTranscript = transcript.trim();
  if (cleanedTranscript.length === 0) {
    throw new Error('Похоже, аудиозапись получилась пустой.');
  }

  const normalizedTranscript = cleanedTranscript.replace(/\s+/g, ' ').trim();
  const transcriptWordCount = normalizedTranscript.split(' ').filter(Boolean).length;
  if (transcriptWordCount < MIN_TRANSCRIPT_WORDS) {
    throw new Error('Мы записали только пару слов. Попробуй сформулировать вариант чуть подробнее и перезапиши.');
  }

  const recentSegments = segments.slice(-4);
  const contextLines = recentSegments
    .map((segment, index) => {
      const orderLabel = `${segment.arc}.${index + 1}`;
      const choicePrefix = segment.optionTitle
        ? `После выбора «${segment.optionTitle}». `
        : '';
      const text = clampString(segment.text.replace(/\s+/g, ' ').trim(), 220);
      return `${orderLabel}: ${choicePrefix}${text}`;
    })
    .join('\n');

  const storyContextSection = contextLines.length > 0
    ? `Недавние сцены:\n${contextLines}`
    : 'История только начинается.';

  const summarySection = summary && summary.trim().length > 0
    ? `Сводка прошлых событий: ${summary}`
    : undefined;

  const systemPrompt = joinSections(
    'Твоя задача — отформатировать голосовой текст пользователя в карточку выбора для истории.',
    'ПРИОРИТЕТ: максимальная близость к оригинальному тексту пользователя!',
    '',
    '🚫 СТРОГО ЗАПРЕЩЕНО:',
    '- Менять смысл или намерение того, что сказал пользователь',
    '- Добавлять имена, места, действия, которых НЕТ в оригинале',
    '- Менять конкретные имена ("Лея" → "подруга")',
    '- Добавлять сильные эмоциональные описания ("с болью в сердце", "радостно")',
    '- Придумывать психологические мотивы, которых пользователь не озвучил',
    '',
    '✅ РАЗРЕШЕНО (минимально):',
    '- Привести к грамматически правильной форме ("пойду к маме" → "Пойти к маме")',
    '- Немного раскрыть для понятности, если текст слишком краток ("окей" → "Согласиться")',
    '- Адаптировать к контексту истории ТОЛЬКО если пользователь явно на неё ссылается',
    '- Исправить очевидные ошибки распознавания речи',
    '',
    'ЖЕСТКИЕ ЛИМИТЫ (НЕЛЬЗЯ ПРЕВЫШАТЬ):',
    '- Формат ответа: чистый JSON {"title": "...", "description": "..."} без Markdown и комментариев.',
    '- Название: максимум 48 символов (3-6 слов)',
    '- Описание: МАКСИМУМ 140 символов (включая пробелы и знаки препинания)',
    '- Если текст не влезает — СОКРАТИ, оставив только СУТЬ',
  );

  const userPrompt = joinSections(
    storyContextSection,
    summarySection,
    '',
    'РАСПОЗНАННЫЙ ТЕКСТ ПОЛЬЗОВАТЕЛЯ:',
    `"""${normalizedTranscript}"""`,
    '',
    'Задача:',
    '1. Сделай краткое название (title): 3-6 слов, до 48 символов',
    '2. Сделай КРАТКОЕ описание (description): 1 предложение, СТРОГО до 140 символов',
    '3. Сохрани главное: имена, ключевое действие, суть',
    '4. Если текст длинный — СОКРАТИ, убрав детали и оставив суть',
    '5. ПРОВЕРЬ длину description — если больше 140 символов, сократи еще',
    '',
    'Примеры (обрати внимание на длину):',
    '',
    'Вход: "Пойду к Лее обсудить эту ситуацию"',
    '{"title": "Пойти к Лее", "description": "Пойти к Лее и обсудить ситуацию"}',
    '',
    'Вход: "Промолчу и сделаю вид что ничего не случилось"',
    '{"title": "Промолчать", "description": "Промолчать и сделать вид, что ничего не случилось"}',
    '',
    'Вход: "Написать пост в фейсбуке о том какая классная подруга Ленка и сколько денег она отдала намекая маме на то как тебе тяжело в надежде что она это прочитает"',
    '{"title": "Написать пост о Ленке", "description": "Написать в фейсбук про Ленку, намекая маме на свою ситуацию"}',
    '',
    'Вход: "Позвоню маме прямо сейчас и расскажу всю правду о том что произошло"',
    '{"title": "Позвонить маме", "description": "Позвонить маме и рассказать правду"}',
  );

  const aiResponse = await callAI({
    system: systemPrompt,
    messages: [
      {
        role: 'user',
        content: userPrompt,
      },
    ],
    temperature: 0.2, // Очень низкая температура для точного следования лимитам
    maxTokens: 300,
    signal,
    claudeApiKey,
    claudeProxyUrl,
    openAIApiKey,
    openAIProxyUrl,
    // Используем Claude (более точно следует инструкциям) вместо GPT-4o-mini
  });

  const { parsed } = parseJsonWithRecovery(aiResponse.text, 'HistoryStory:custom-option');

  const optionSource = (parsed as { title?: unknown; description?: unknown }) ?? {};

  const title =
    typeof optionSource.title === 'string' && optionSource.title.trim().length > 0
      ? clampString(enforceSingleLine(optionSource.title), 48)
      : clampString(enforceSingleLine(normalizedTranscript), 48);

  const description =
    typeof optionSource.description === 'string' && optionSource.description.trim().length > 0
      ? clampString(enforceSingleLine(optionSource.description), 140)
      : clampString(enforceSingleLine(normalizedTranscript), 140);

  const id = `custom-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;

  return {
    id,
    title,
    description,
    kind: 'custom',
    transcript: normalizedTranscript,
    rawUserText: normalizedTranscript,
  };
}
