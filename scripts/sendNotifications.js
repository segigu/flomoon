#!/usr/bin/env node

const webpush = require('web-push');

const fetch = (...args) => {
  if (typeof globalThis.fetch === 'function') {
    return globalThis.fetch(...args);
  }
  return import('node-fetch').then(({ default: fetchModule }) => fetchModule(...args));
};

const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const VAPID_PUBLIC_KEY = process.env.VAPID_PUBLIC_KEY;
const VAPID_PRIVATE_KEY = process.env.VAPID_PRIVATE_KEY;
const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY || '';
const CLAUDE_MODEL = 'claude-sonnet-4-5-20250929';

const CONFIG_FILE = 'nastia-config.json';

const MS_IN_DAY = 24 * 60 * 60 * 1000;
const MOSCOW_TZ = 'Europe/Moscow';
const BERLIN_TZ = 'Europe/Berlin';
const NOTIFICATION_START_HOUR = 7;
const NOTIFICATION_END_HOUR = 21;
const NOTIFICATION_SLOT_MINUTES = 5;
const MIN_NOTIFICATION_MINUTES = NOTIFICATION_START_HOUR * 60;
const MAX_NOTIFICATION_MINUTES = NOTIFICATION_END_HOUR * 60 + (60 - NOTIFICATION_SLOT_MINUTES);
const NASTIA_BIRTH_YEAR = 1992;
const NASTIA_BIRTH_MONTH = 3; // April (0-indexed)
const NASTIA_BIRTH_DAY = 12;

if (!GITHUB_TOKEN) {
  console.error('Missing GITHUB_TOKEN');
  process.exit(1);
}

if (!VAPID_PUBLIC_KEY || !VAPID_PRIVATE_KEY) {
  console.error('Missing VAPID keys');
  process.exit(1);
}

webpush.setVapidDetails(
  'mailto:noreply@nastia-calendar.com',
  VAPID_PUBLIC_KEY,
  VAPID_PRIVATE_KEY
);

const responseSchema = {
  name: 'push_notification',
  schema: {
    type: 'object',
    additionalProperties: false,
    required: ['title', 'body'],
    properties: {
      title: {
        type: 'string',
        description: '–ò–º—è –≤—ã–º—ã—à–ª–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –Ω–∞ —Ä—É—Å—Å–∫–æ–º –≤ 1-3 —Å–ª–æ–≤–∞—Ö (—Ç–æ–ª—å–∫–æ –∏–º—è/—Ñ–∞–º–∏–ª–∏—è/–æ—Ç—á–µ—Å—Ç–≤–æ), –±–µ–∑ —ç–º–æ–¥–∑–∏.',
        maxLength: 48,
        pattern: '^(?![–ù–Ω]–∞—Å—Ç)(?![–Ω–ù]–∞—Å—Ç)[–ê-–Ø–Å][–ê-–Ø–Å–∞-—è—ë-]*(?:\\s[–ê-–Ø–Å][–ê-–Ø–Å–∞-—è—ë-]*){0,2}$',
      },
      body: {
        type: 'string',
        description: 'Push body up to 110 characters with 1-2 emojis and biting supportive sarcasm.',
        maxLength: 150,
      },
    },
  },
};

const fallbackMessages = {
  fertile_window: {
    title: '–õ—é–¥–º–∏–ª–∞ –§–µ—Ä—Ç–∏–ª—å–Ω–∞—è',
    body: '–ù–∞—Å—Ç—é—à, —ç—Ç–æ –õ—é–¥–º–∏–ª–∞ –§–µ—Ä—Ç–∏–ª—å–Ω–∞—è: –∑–æ–Ω–∞ —Ä–∏—Å–∫–∞, –±–µ–∑ –∑–∞—â–∏—Ç—ã –Ω–∏ —à–∞–≥—É. üíã',
  },
  ovulation_day: {
    title: '–§—ë–¥–æ—Ä –ü–ª–æ–¥–æ–≤–∏—Ç—ã–π',
    body: '–ù–∞—Å—Ç—ë–Ω–∞, –§—ë–¥–æ—Ä –ü–ª–æ–¥–æ–≤–∏—Ç—ã–π –Ω–∞ –ø—Ä–æ–≤–æ–¥–µ: —Å–µ–≥–æ–¥–Ω—è –æ–≤—É–ª—è—Ü–∏—è, –ø—Ä–∏–∫—Ä—ã–≤–∞–π—Å—è! üî•',
  },
  period_forecast: {
    title: '–ó–æ—è –ü–ú–°–æ–≤–∞',
    body: '–ù–∞—Å—Ç—é—Ö, –ó–æ—è –ü–ú–°–æ–≤–∞ –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–µ—Ç: –ø–∞—Ä–∞ –¥–Ω–µ–π –¥–æ —à—Ç–æ—Ä–º–∞, –∑–∞–ø–∞—Å–∞–π—Å—è —Ç–µ—Ä–ø–µ–Ω–∏–µ–º. üôÑ',
  },
  period_start: {
    title: '–ú–∞—Ä—Ñ–∞ –ö—Ä–æ–≤—è–∫–æ–≤–∞',
    body: '–ù–∞—Å—Ç—ë–Ω–∞, –ú–∞—Ä—Ñ–∞ –ö—Ä–æ–≤—è–∫–æ–≤–∞ —Ä–∞–ø–æ—Ä—Ç—É–µ—Ç: –ø–æ—Ç–æ–∫ –Ω–∞—á–∞–ª—Å—è, –≥—Ä–µ–ª–∫—É –≤ –∑—É–±—ã. ü©∏',
  },
  period_check: {
    title: '–í–µ—Ä–æ–Ω–∏–∫–∞ –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è',
    body: '–ù–∞—Å—Ç—é—Ö, –í–µ—Ä–æ–Ω–∏–∫–∞ –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è –Ω–∞ —Å–≤—è–∑–∏: –¥–µ–Ω—å –• —Å–µ–≥–æ–¥–Ω—è, –æ—Ç–º–µ—Ç—å, –µ—Å–ª–∏ —É–∂–µ –ø–æ—à–ª–æ. üëÄ',
  },
  period_waiting: {
    title: '–ì–ª–∞—à–∞ –¢–µ—Ä–ø–µ–ª–∏–≤–∞—è',
    body: '–ù–∞—Å—Ç—ë–Ω–∞, –ì–ª–∞—à–∞ –¢–µ—Ä–ø–µ–ª–∏–≤–∞—è: –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–µ–Ω—å –∫–∞–∫, –ø—Ä–∏—Å–ª—É—à–∞–π—Å—è –∏ —á–µ—Ä–∫–∞–Ω–∏ –≤ –¥–Ω–µ–≤–Ω–∏–∫. ü§î',
  },
  period_delay_warning: {
    title: '–†–∏–º–º–∞ –¢—Ä–µ–≤–æ–∂–Ω–∞—è',
    body: '–ù–∞—Å—Ç—é—à, –†–∏–º–º–∞ –¢—Ä–µ–≤–æ–∂–Ω–∞—è –≤ –ø–∞–Ω–∏–∫–µ: —É–∂ –±–æ–ª—å–Ω–æ —Ç—è–Ω–µ—Ç, –º–æ–∂–µ—Ç, —Ç–µ—Å—Ç –Ω–∞ –≤—Å—è–∫–∏–π? üò¨',
  },
  period_confirmed_day0: {
    title: '–¢–∞–º–∞—Ä–∞ –ü–ª–µ–¥–æ–≤–∞—è',
    body: '–ù–∞—Å—Ç—ë–Ω–∞, –¢–∞–º–∞—Ä–∞ –ü–ª–µ–¥–æ–≤–∞—è: —Å—Ç–∞—Ä—Ç –ø—Ä–∏–Ω—è—Ç, –ø–ª–µ–¥, –≥—Ä–µ–ª–∫–∞ –∏ –º–∏–Ω–∏–º—É–º –ø–æ–¥–≤–∏–≥–æ–≤. üõãÔ∏è',
  },
  period_confirmed_day1: {
    title: '–°–æ–Ω—è –ì—Ä–µ–ª–æ—á–Ω–∏–∫–æ–≤–∞',
    body: '–ù–∞—Å—Ç—é—à, –°–æ–Ω—è –ì—Ä–µ–ª–æ—á–Ω–∏–∫–æ–≤–∞: –≤—Ç–æ—Ä–æ–π –¥–µ–Ω—å ‚Äî –≥—Ä–µ–ª–∫—É –∫ –ø—É–∑–∏–∫—É –∏ —Å–µ—Ä–∏–∞–ª—ã –≤ –±–æ–π. üî•',
  },
  period_confirmed_day2: {
    title: '–ò–Ω–≥–∞ –ñ–µ–ª–µ–∑–∏—Å—Ç–∞—è',
    body: '–ù–∞—Å—Ç—ë–Ω–∞, –ò–Ω–≥–∞ –ñ–µ–ª–µ–∑–∏—Å—Ç–∞—è: —Ç—Ä–µ—Ç–∏–π –¥–µ–Ω—å, –ø–µ–π –≤–æ–¥—É –∏ –±–µ—Ä–µ–≥–∏ –Ω–µ—Ä–≤—ã, —Å–ª—ã—à–∏—à—å? üí™',
  },
  birthday: {
    title: '–ì–∞–ª—è –ò–º–µ–Ω–∏–Ω–Ω–∏—Ü–∞',
    body: '–ù–∞—Å—Ç—é—à, —Å –¥–Ω—é—Ö–æ–π! –ì–∞–ª—è –ò–º–µ–Ω–∏–Ω–Ω–∏—Ü–∞ –Ω–∞ —Å–≤—è–∑–∏: —É—Å—Ç—Ä–æ–∏–º —à—É–º–Ω—ã–π –ø—Ä–∞–∑–¥–Ω–∏–∫ –∏ –Ω–æ–ª—å –¥—Ä–∞–º—ã. üéâüíú',
  },
};

const TITLE_REGEX = /^(?![–ù–Ω]–∞—Å—Ç)[–ê-–Ø–Å][–ê-–Ø–Å–∞-—è—ë-]*(?:\s[–ê-–Ø–Å][–ê-–Ø–Å–∞-—è—ë-]*){0,2}$/;
const EMOJI_REGEX = /[\u{1F300}-\u{1FAFF}\u{1F004}-\u{1F9FF}]/u;

function truncateWithEllipsis(text, limit = 110) {
  const trimmed = (text || '').trim();
  if (trimmed.length <= limit) {
    return trimmed;
  }
  return `${trimmed.slice(0, Math.max(0, limit - 1)).trim()}‚Ä¶`;
}

function isValidPersonaTitle(value) {
  if (!value) {
    return false;
  }
  return TITLE_REGEX.test(value.trim());
}

function ensureEmojiPresent(text) {
  if (!text) {
    return '–ù–∞—Å—Ç—é—à, –¥–µ—Ä–∂–∏ –∑–∞—â–∏—Ç—É. üõ°Ô∏è';
  }
  const truncated = truncateWithEllipsis(text);
  if (EMOJI_REGEX.test(truncated)) {
    return truncated;
  }
  return truncateWithEllipsis(`${truncated} üõ°Ô∏è`);
}

function toZonedDate(date, timeZone) {
  return new Date(date.toLocaleString('en-US', { timeZone }));
}

function getZonedNow(timeZone) {
  return toZonedDate(new Date(), timeZone);
}

function getBerlinNow() {
  return getZonedNow(BERLIN_TZ);
}

function getBerlinDayKey(date = new Date()) {
  const zoned = toZonedDate(date, BERLIN_TZ);
  zoned.setHours(0, 0, 0, 0);
  return zoned.toISOString();
}

function getMinutesSinceMidnight(date) {
  return date.getHours() * 60 + date.getMinutes();
}

function isNastiaBirthday(date) {
  return date.getMonth() === NASTIA_BIRTH_MONTH && date.getDate() === NASTIA_BIRTH_DAY;
}

function getNastiaAgeOn(date) {
  let age = date.getFullYear() - NASTIA_BIRTH_YEAR;
  const hasBirthdayHappened =
    date.getMonth() > NASTIA_BIRTH_MONTH ||
    (date.getMonth() === NASTIA_BIRTH_MONTH && date.getDate() >= NASTIA_BIRTH_DAY);
  if (!hasBirthdayHappened) {
    age -= 1;
  }
  return age;
}

function formatClock(date) {
  return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
}

function formatMinutesToClock(minutes) {
  const hours = Math.floor(minutes / 60);
  const mins = minutes % 60;
  return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
}

function pickRandomNotificationMinutes() {
  const slots = Math.floor((MAX_NOTIFICATION_MINUTES - MIN_NOTIFICATION_MINUTES) / NOTIFICATION_SLOT_MINUTES) + 1;
  const slotIndex = Math.floor(Math.random() * slots);
  return MIN_NOTIFICATION_MINUTES + slotIndex * NOTIFICATION_SLOT_MINUTES;
}

function isMinutesWithinWindow(minutes) {
  if (typeof minutes !== 'number' || Number.isNaN(minutes)) {
    return false;
  }
  if (minutes < MIN_NOTIFICATION_MINUTES || minutes > MAX_NOTIFICATION_MINUTES) {
    return false;
  }
  return minutes % NOTIFICATION_SLOT_MINUTES === 0;
}

function formatBerlinClockFromIso(value) {
  if (!value) {
    return 'unknown';
  }
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return 'unknown';
  }
  const zoned = toZonedDate(date, BERLIN_TZ);
  return formatClock(zoned);
}

function getLatestNotificationForDay(log, dayKey) {
  if (!log || !Array.isArray(log.notifications)) {
    return null;
  }
  for (const entry of log.notifications) {
    if (!entry?.sentAt) {
      continue;
    }
    const entryKey = getBerlinDayKey(new Date(entry.sentAt));
    if (entryKey === dayKey) {
      return entry;
    }
  }
  return null;
}

function startOfDay(date) {
  const copy = new Date(date);
  copy.setHours(0, 0, 0, 0);
  return copy;
}

function addDays(date, days) {
  const copy = new Date(date);
  copy.setDate(copy.getDate() + days);
  return copy;
}

function getMoscowToday() {
  const now = new Date();
  const moscowString = now.toLocaleString('en-US', { timeZone: MOSCOW_TZ });
  const moscowDate = new Date(moscowString);
  moscowDate.setHours(0, 0, 0, 0);
  return moscowDate;
}

function diffInDays(from, to) {
  return Math.round((to.getTime() - from.getTime()) / MS_IN_DAY);
}

function formatRussianDate(date) {
  return date.toLocaleDateString('ru-RU', {
    day: 'numeric',
    month: 'long',
  });
}

async function fetchFromGitHub(url) {
  const response = await fetch(url, {
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      Accept: 'application/vnd.github.v3+json',
    },
  });
  return response;
}

async function loadRepoJson(username, filename, fallbackValue) {
  const url = `https://api.github.com/repos/${username}/nastia-data/contents/${filename}`;
  const response = await fetchFromGitHub(url);

  if (response.status === 404) {
    console.warn(`File ${filename} not found (404), using fallback value`);
    return { value: fallbackValue, corrupted: true };
  }

  if (!response.ok) {
    throw new Error(`Failed to load ${filename}: ${response.statusText}`);
  }

  const payload = await response.json();
  const content = Buffer.from(payload.content, 'base64').toString('utf8');

  // Handle empty or invalid content
  if (!content || content.trim() === '') {
    console.warn(`File ${filename} is empty, using fallback value`);
    return { value: fallbackValue, corrupted: true };
  }

  try {
    return { value: JSON.parse(content), corrupted: false };
  } catch (error) {
    console.warn(`File ${filename} contains invalid JSON, using fallback value:`, error.message);
    return { value: fallbackValue, corrupted: true };
  }
}

async function loadConfig(username) {
  try {
    const result = await loadRepoJson(username, CONFIG_FILE, null);
    return result.value;
  } catch (error) {
    console.warn('Failed to load config, continuing with defaults:', error.message);
    return null;
  }
}

async function saveConfig(username, config) {
  const url = `https://api.github.com/repos/${username}/nastia-data/contents/${CONFIG_FILE}`;

  const content = Buffer.from(JSON.stringify(config, null, 2)).toString('base64');

  let sha;
  const getResponse = await fetch(url, {
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      Accept: 'application/vnd.github.v3+json',
    },
  });

  if (getResponse.ok) {
    const fileData = await getResponse.json();
    sha = fileData.sha;
  }

  const putResponse = await fetch(url, {
    method: 'PUT',
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      message: `Update config ${new Date().toISOString()}`,
      content,
      ...(sha ? { sha } : {}),
    }),
  });

  if (!putResponse.ok) {
    const errorPayload = await putResponse.text();
    throw new Error(`Failed to save config: ${errorPayload}`);
  }
}

function ensureNotificationSchedule(config) {
  const todayKey = getBerlinDayKey();
  const existing = config?.notificationSchedule;
  const hasValidExisting =
    existing &&
    existing.dayKey === todayKey &&
    isMinutesWithinWindow(existing.targetMinutes);

  if (hasValidExisting) {
    const schedule = { ...existing };
    let scheduleUpdated = false;

    if (schedule.timezone !== BERLIN_TZ) {
      schedule.timezone = BERLIN_TZ;
      scheduleUpdated = true;
    }

    if (schedule.slotMinutes !== NOTIFICATION_SLOT_MINUTES) {
      schedule.slotMinutes = NOTIFICATION_SLOT_MINUTES;
      scheduleUpdated = true;
    }

    const expectedTargetTime = formatMinutesToClock(schedule.targetMinutes);
    if (schedule.targetTime !== expectedTargetTime) {
      schedule.targetTime = expectedTargetTime;
      scheduleUpdated = true;
    }

    if (!schedule.generatedAt) {
      schedule.generatedAt = new Date().toISOString();
      scheduleUpdated = true;
    }

    if (scheduleUpdated) {
      config.notificationSchedule = schedule;
    }

    return {
      schedule,
      updated: scheduleUpdated,
    };
  }

  const targetMinutes = pickRandomNotificationMinutes();
  const schedule = {
    dayKey: todayKey,
    targetMinutes,
    targetTime: formatMinutesToClock(targetMinutes),
    timezone: BERLIN_TZ,
    slotMinutes: NOTIFICATION_SLOT_MINUTES,
    generatedAt: new Date().toISOString(),
  };

  config.notificationSchedule = schedule;
  return { schedule, updated: true };
}

async function prepareConfigAndSchedule(username, trimmedClaudeKey) {
  const currentConfig = await loadConfig(username);
  const nextConfig = { ...(currentConfig ?? {}) };
  let configDirty = false;
  let claudeUpdated = false;

  if (trimmedClaudeKey) {
    const currentKey = currentConfig?.claude?.apiKey;
    if (currentKey !== trimmedClaudeKey) {
      nextConfig.claude = {
        ...(currentConfig?.claude ?? {}),
        apiKey: trimmedClaudeKey,
      };
      configDirty = true;
      claudeUpdated = true;
    }
  } else {
    console.warn('CLAUDE_API_KEY secret is empty; remote config not updated');
  }

  const scheduleResult = ensureNotificationSchedule(nextConfig);
  if (scheduleResult.updated) {
    configDirty = true;
  }

  if (configDirty) {
    nextConfig.updatedAt = new Date().toISOString();
    try {
      await saveConfig(username, nextConfig);
      if (claudeUpdated) {
        console.log('Configuration file updated with Claude API key');
      }
      if (scheduleResult.updated) {
        console.log(`Notification schedule for today set to ${scheduleResult.schedule.targetTime} (${BERLIN_TZ})`);
      }
    } catch (error) {
      console.error('Failed to update configuration file:', error.message);
    }
  }

  return {
    config: nextConfig,
    schedule: scheduleResult.schedule,
  };
}

function computeCycleStats(cycles) {
  if (!Array.isArray(cycles) || cycles.length === 0) {
    return null;
  }

  const sorted = [...cycles]
    .map(cycle => ({ ...cycle, startDate: startOfDay(new Date(cycle.startDate)) }))
    .sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

  if (sorted.length === 0) {
    return null;
  }

  const cycleLengths = [];
  for (let i = 1; i < sorted.length; i += 1) {
    const prev = sorted[i - 1].startDate;
    const current = sorted[i].startDate;
    cycleLengths.push(diffInDays(prev, current));
  }

  const averageLength = cycleLengths.length > 0
    ? Math.round(cycleLengths.reduce((sum, len) => sum + len, 0) / cycleLengths.length)
    : 28;

  const lastStart = sorted[sorted.length - 1].startDate;
  const nextPeriod = startOfDay(addDays(lastStart, averageLength));
  const ovulationDay = startOfDay(addDays(nextPeriod, -14));
  const fertileStart = startOfDay(addDays(ovulationDay, -5));

  return {
    lastStart,
    nextPeriod,
    averageLength,
    ovulationDay,
    fertileStart,
    fertileEnd: ovulationDay,
  };
}

function pickNotificationType(today, stats) {
  if (isNastiaBirthday(today)) {
    return {
      type: 'birthday',
      metadata: {
        birthdayAge: getNastiaAgeOn(today),
      },
    };
  }

  const predictedStart = startOfDay(stats.nextPeriod);
  const ovulationDay = startOfDay(stats.ovulationDay);
  const fertileStart = startOfDay(stats.fertileStart);
  const fertileEndExclusive = startOfDay(stats.fertileEnd);

  const daysUntilPeriod = diffInDays(today, predictedStart);
  const daysUntilOvulation = diffInDays(today, ovulationDay);

  let daysSinceLastStart = null;
  let lastStartIso = null;
  if (stats.lastStart) {
    const lastStart = startOfDay(stats.lastStart);
    daysSinceLastStart = diffInDays(lastStart, today);
    lastStartIso = lastStart.toISOString();
  }

  const hasRecentPeriodStart =
    typeof daysSinceLastStart === 'number' &&
    daysSinceLastStart >= 0 &&
    daysSinceLastStart <= 2;

  if (hasRecentPeriodStart) {
    if (daysSinceLastStart === 0) {
      return {
        type: 'period_confirmed_day0',
        metadata: {
          daysSincePeriodStart: daysSinceLastStart,
          periodStartDate: lastStartIso,
        },
      };
    }
    if (daysSinceLastStart === 1) {
      return {
        type: 'period_confirmed_day1',
        metadata: {
          daysSincePeriodStart: daysSinceLastStart,
          periodStartDate: lastStartIso,
        },
      };
    }
    return {
      type: 'period_confirmed_day2',
      metadata: {
        daysSincePeriodStart: daysSinceLastStart,
        periodStartDate: lastStartIso,
      },
    };
  }

  if (daysUntilPeriod === 0) {
    return {
      type: 'period_check',
      metadata: {
        daysUntilPeriod,
        predictedDateIso: predictedStart.toISOString(),
      },
    };
  }

  if (daysUntilPeriod > 0 && daysUntilPeriod <= 5) {
    return {
      type: 'period_forecast',
      metadata: {
        daysUntilPeriod,
        predictedDateIso: predictedStart.toISOString(),
      },
    };
  }

  if (daysUntilPeriod < 0) {
    const daysPastPrediction = Math.abs(daysUntilPeriod);
    if (daysPastPrediction <= 2) {
      return {
        type: 'period_waiting',
        metadata: {
          daysPastPrediction,
          predictedDateIso: predictedStart.toISOString(),
        },
      };
    }
    return {
      type: 'period_delay_warning',
      metadata: {
        daysPastPrediction,
        predictedDateIso: predictedStart.toISOString(),
      },
    };
  }

  if (daysUntilOvulation === 0) {
    return {
      type: 'ovulation_day',
      metadata: { daysUntilOvulation },
    };
  }

  if (today.getTime() >= fertileStart.getTime() && today.getTime() < fertileEndExclusive.getTime()) {
    return {
      type: 'fertile_window',
      metadata: {
        daysUntilOvulation,
      },
    };
  }

  return null;
}

function buildPrompt(type, context) {
  const base = `–¢—ã ‚Äî –ù–∞—Å—Ç–∏–Ω–∞ –ª—É—á—à–∞—è –ø–æ–¥—Ä—É–≥–∞ —Å –∂—ë—Å—Ç–∫–∏–º, –Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–º –∂–µ–Ω—Å–∫–∏–º —Å–∞—Ä–∫–∞–∑–º–æ–º. –ü–∏—à–∏ –ø–æ-—Ä—É—Å—Å–∫–∏ –¥–µ—Ä–∑–∫–æ –∏ –ø—Ä—è–º–æ, –æ–±—Ä–∞—â–∞–π—Å—è –∫ –ù–∞—Å—Ç–µ –ø–æ-—Å–≤–æ–π—Å–∫–∏ (–ù–∞—Å—Ç—é—à, –ù–∞—Å—Ç—ë–Ω, –ù–∞—Å—Ç—ë–Ω–∫–∞, –ù–∞—Å—Ç—é—à–∫–∞, –ù–∞—Å—Ç—ë–Ω–∞, –¥–µ—Ç–∫–∞, –∏–Ω–æ–≥–¥–∞ –º–æ–∂–Ω–æ –ø–æ —Ñ–∞–º–∏–ª–∏–∏ - –û—Ä–ª–æ–≤–∞).
–ó–∞–¥–∞—á–∞: –ø—Ä–∏–¥—É–º–∞—Ç—å push-—É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –∫–∞–ª–µ–Ω–¥–∞—Ä—è —Ü–∏–∫–ª–∞.
–§–æ—Ä–º–∞—Ç:
- –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∏–∑ 1-3 —Å–ª–æ–≤: —Ç–æ–ª—å–∫–æ –≤—ã–º—ã—à–ª–µ–Ω–Ω–æ–µ –∏–º—è, —Ñ–∞–º–∏–ª–∏—è –∏/–∏–ª–∏ –æ—Ç—á–µ—Å—Ç–≤–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞. –ü–µ—Ä—Å–æ–Ω–∞–∂ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–æ–≤—ã–º –≤ –∫–∞–∂–¥–æ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–∏, —Å –∏–≥—Ä–∏–≤—ã–º –æ—Ç—Ç–µ–Ω–∫–æ–º, —Å–≤—è–∑–∞–Ω–Ω—ã–º —Å —Ç–µ–º–æ–π —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ—Å—Ç–∏, –≥–æ—Ä–º–æ–Ω–æ–≤, –∑–∞—â–∏—Ç—ã, –±–µ—Ä–µ–º–µ–Ω–Ω–æ—Å—Ç–∏ –∏ —Ç.–ø. –ù–∏–∫–∞–∫–∏—Ö –æ–±—Ä–∞—â–µ–Ω–∏–π –∫ –ù–∞—Å—Ç–µ. –ü—Ä–∏–º–µ—Ä—ã (–Ω–µ –ø–æ–≤—Ç–æ—Ä—è–π –¥–æ—Å–ª–æ–≤–Ω–æ): ¬´–õ—é–¥–º–∏–ª–∞ –§–µ—Ä—Ç–∏–ª—å–Ω–∞—è¬ª, ¬´–§—ë–¥–æ—Ä –ü–ª–æ–¥–æ–≤–∏—Ç—ã–π¬ª, ¬´–û–ª–µ—Å—è –û–≤—É–ª—è—Ç–æ—Ä–æ–≤–Ω–∞¬ª, ¬´–ú–∞—Ä—Ñ–∞ –ö–æ–Ω—Ç—Ä–∞—Ü–µ–ø—Ç–æ–≤–Ω–∞¬ª, ¬´–ì—Ä–∏—à–∞ –ü—Ä–µ–∑–µ—Ä–≤–∞—Ç–æ—Ä–æ–≤¬ª.
- –¢–µ–ª–æ –¥–æ 110 —Å–∏–º–≤–æ–ª–æ–≤ —Å –æ–±—Ä–∞—â–µ–Ω–∏–µ–º –∫ –ù–∞—Å—Ç–µ, 1-2 —ç–º–æ–¥–∑–∏ –∏ –∂—ë—Å—Ç–∫–∏–º, –Ω–æ –∑–∞–±–æ—Ç–ª–∏–≤—ã–º —Å–∞—Ä–∫–∞–∑–º–æ–º. –ü–∏—à–∏ –æ—Ç –ª–∏—Ü–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞, –±—É–¥—Ç–æ –æ–Ω —à–ª—ë—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç. –ù–∏–∫–∞–∫–æ–π –º—è–≥–∫–æ—Å—Ç–∏, –Ω–æ –∏ –±–µ–∑ –æ–±—Å—Ü–µ–Ω–Ω–æ–π –ª–µ–∫—Å–∏–∫–∏ –∏ —É–Ω–∏–∂–µ–Ω–∏–π.
–°–µ–≥–æ–¥–Ω—è: ${context.todayHuman}. –ü—Ä–æ–≥–Ω–æ–∑ —Å—Ç–∞—Ä—Ç–∞ –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏: ${context.periodHuman}.`;

  switch (type) {
    case 'fertile_window':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ, –¥–æ –æ–≤—É–ª—è—Ü–∏–∏ ${Math.abs(context.daysUntilOvulation)} ${context.daysWord}. –ñ—ë—Å—Ç–∫–æ –∏ —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ –ø—Ä–µ–¥—É–ø—Ä–µ–¥–∏ –ø—Ä–æ —Ä–∏—Å–∫ –∑–∞–ª—ë—Ç–∞ –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –∑–∞—â–∏—Ç—ã. –î—Ä–∞–º–∞ –Ω–µ –Ω—É–∂–Ω–∞.`;
    case 'ovulation_day':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: —Å–µ–≥–æ–¥–Ω—è –æ–≤—É–ª—è—Ü–∏—è. –ü—Ä—è–º–æ –∏ —Ä–µ–∑–∫–æ —Å–∫–∞–∂–∏ –ø—Ä–æ –ø–∏–∫ —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –∏ —á—Ç–æ –±–µ–∑ –∫–æ–Ω—Ç—Ä–∞—Ü–µ–ø—Ü–∏–∏ ‚Äî –∏–≥—Ä–∞–µ—à—å —Å –æ–≥–Ω—ë–º.`;
    case 'period_forecast':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: –¥–æ –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏ ${Math.abs(context.daysUntilPeriod)} ${context.daysWord}. –ñ—ë—Å—Ç–∫–æ, –Ω–æ –ø–æ-—Å–µ—Å—Ç—Ä–∏–Ω—Å–∫–∏: –Ω–∞–ø–æ–º–Ω–∏, —á—Ç–æ —à—Ç–æ—Ä–º —É–∂–µ –Ω–∞ –ø–æ–¥—Ö–æ–¥–µ, –ø–æ–¥–≥–æ—Ç–æ–≤—å –≥—Ä–µ–ª–∫—É –∏ —à–æ–∫–æ–ª–∞–¥.`;
    case 'period_check':
    case 'period_start':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞ ${context.periodHuman} ‚Äî —Ç–æ –µ—Å—Ç—å —Å–µ–≥–æ–¥–Ω—è. –°–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ –ø–æ–ø—Ä–æ—Å–∏ –ù–∞—Å—Ç—é –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, –Ω–µ –Ω–∞—á–∞–ª–æ—Å—å –ª–∏ —É–∂–µ, –∏ –Ω–∞–º–µ–∫–Ω–∏ –æ—Ç–º–µ—Ç–∏—Ç—å —Å—Ç–∞—Ä—Ç. –ù–∏–∫–∞–∫–æ–≥–æ –º–æ—Ä–∞–ª–∏–∑–∞—Ç–æ—Ä—Å—Ç–≤–∞.`;
    case 'period_waiting':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è –∑–∞–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è —É–∂–µ ${context.daysPastPrediction} ${context.daysPastPredictionWord}. –ü–æ–¥–¥–µ—Ä–∂–∏ –ù–∞—Å—Ç—é, —Å–ø—Ä–æ—Å–∏ –ø—Ä–æ –æ—â—É—â–µ–Ω–∏—è –∏ —Ç–æ–Ω–∫–æ –Ω–∞–ø–æ–º–Ω–∏ –æ—Ç–º–µ—Ç–∏—Ç—å –Ω–∞—á–∞–ª–æ, –±–µ–∑ –∑–∞–Ω—É–¥—Å—Ç–≤–∞.`;
    case 'period_delay_warning':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª–∏—Ç—Å—è ${context.daysPastPrediction} ${context.daysPastPredictionWord}. –° —Å–∞—Ä–∫–∞–∑–º–æ–º –ø–µ—Ä–µ–∂–∏–≤–∞–π, –ø—Ä–µ–¥–ª–æ–∂–∏ –ø—Ä–∏—Å–ª—É—à–∞—Ç—å—Å—è –∫ —Ç–µ–ª—É, –Ω–∞–º–µ–∫–Ω–∏ –ø—Ä–æ —Ç–µ—Å—Ç –∏–ª–∏ –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é, –Ω–æ –±–µ–∑ –ø–∞–Ω–∏–∫–∏.`;
    case 'period_confirmed_day0':
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: –ù–∞—Å—Ç—è –æ—Ç–º–µ—Ç–∏–ª–∞, —á—Ç–æ –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è –Ω–∞—á–∞–ª–∞—Å—å —Å–µ–≥–æ–¥–Ω—è (${context.periodStartHuman}). –û–±–Ω–∏–º–∏ —Å–ª–æ–≤–∞–º–∏, –ø–æ–¥–∫–∏–Ω–∏ –∏–¥–µ–∏ —É—Ö–æ–¥–∞ (–≥—Ä–µ–ª–∫–∞, –ø–ª–µ–¥, –ø–æ–∫–æ–π) –∏ –ø–æ—Ö–≤–∞–ª–∏ –∑–∞ –æ—Ç–º–µ—Ç–∫—É.`;
    case 'period_confirmed_day1': {
      const days = typeof context.daysSincePeriodStart === 'number' ? context.daysSincePeriodStart : 1;
      const dayWord = days === 1 ? '–≤—Ç–æ—Ä–æ–π –¥–µ–Ω—å' : `${days + 1}-–π –¥–µ–Ω—å`;
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: ${dayWord} –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏ (—Å—Ç–∞—Ä—Ç –±—ã–ª ${context.periodStartHuman}). –°–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏, —Å–ø—Ä–æ—Å–∏ –ø—Ä–æ —Å–∞–º–æ—á—É–≤—Å—Ç–≤–∏–µ –∏ –Ω–∞–ø–æ–º–Ω–∏ –±–µ—Ä–µ—á—å —Å–∏–ª—ã.`;
    }
    case 'period_confirmed_day2': {
      const days = typeof context.daysSincePeriodStart === 'number' ? context.daysSincePeriodStart : 2;
      const dayWord = days === 2 ? '—Ç—Ä–µ—Ç–∏–π –¥–µ–Ω—å' : `${days + 1}-–π –¥–µ–Ω—å`;
      return `${base}
–°–∏—Ç—É–∞—Ü–∏—è: ${dayWord} –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏ (—Å—Ç–∞—Ä—Ç ${context.periodStartHuman}). –ü–æ–¥–¥–µ—Ä–∂–∏, –Ω–∞–ø–æ–º–Ω–∏ –ø—Ä–æ —Å–ø–æ–∫–æ–π–Ω—ã–π —Ä–µ–∂–∏–º –∏ –Ω–∞–º–µ–∫–Ω–∏, —á—Ç–æ –ù–∞—Å—Ç—è –≤—Å—ë –¥–µ—Ä–∂–∏—Ç –ø–æ–¥ –∫–æ–Ω—Ç—Ä–æ–ª–µ–º.`;
    }
    case 'birthday':
      return `–¢—ã ‚Äî –ù–∞—Å—Ç–∏–Ω–∞ –ª—É—á—à–∞—è –ø–æ–¥—Ä—É–≥–∞ —Å –∂—ë—Å—Ç–∫–∏–º, –Ω–æ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—â–∏–º —Å–∞—Ä–∫–∞–∑–º–æ–º. –ü–∏—à–∏ –ø–æ-—Ä—É—Å—Å–∫–∏, —Ñ–æ—Ä–º–∞—Ç push: –Ω–æ–≤—ã–π –ø–µ—Ä—Å–æ–Ω–∞–∂ –≤ –∑–∞–≥–æ–ª–æ–≤–∫–µ (1-3 —Å–ª–æ–≤–∞) –∏ –∫–æ—Ä–æ—Ç–∫–æ–µ —Ç–µ–ª–æ —Å 1-2 —ç–º–æ–¥–∑–∏.
–°–µ–≥–æ–¥–Ω—è ${context.todayHuman} –∏ –ù–∞—Å—Ç—é—à–µ –∏—Å–ø–æ–ª–Ω—è–µ—Ç—Å—è ${context.birthdayAge}. –ü–æ–∑–¥—Ä–∞–≤—å –µ—ë –¥–µ—Ä–∑–∫–æ –∏ —Ç–µ–ø–ª–æ, –±—É–¥—Ç–æ –ø–æ–¥—Ä—É–≥–∞ —à–ª—ë—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ —á–∞—Ç. –°–¥–µ–ª–∞–π –Ω–∞–º—ë–∫ –Ω–∞ –ø—Ä–∞–∑–¥–Ω–∏–∫, –∑–∞–±–æ—Ç—É –æ —Å–µ–±–µ –∏ –µ—ë —Å—É–ø–µ—Ä—Å–∏–ª—É –≤–µ—Å—Ç–∏ —Ü–∏–∫–ª. –ë–µ–∑ –æ—Ñ–∏—Ü–∏–æ–∑–∞ –∏ –ø–∞—Ñ–æ—Å–∞, —Ç–æ–ª—å–∫–æ –∂–∏–≤–∞—è —è–∑–≤–∏—Ç–µ–ª—å–Ω–∞—è –ª—é–±–æ–≤—å.`;
    default:
      return base;
  }
}

function getDaysWord(value) {
  const absValue = Math.abs(value);
  if (absValue === 1) return '–¥–µ–Ω—å';
  if (absValue >= 2 && absValue <= 4) return '–¥–Ω—è';
  return '–¥–Ω–µ–π';
}

async function generateMessage(type, context, cache) {
  if (cache.has(type)) {
    return cache.get(type);
  }

  if (!CLAUDE_API_KEY) {
    const fallback = applyPersonaTemplate(fallbackMessages[type]);
    cache.set(type, fallback);
    return fallback;
  }

  const prompt = buildPrompt(type, context);

  try {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: CLAUDE_MODEL,
        max_tokens: 300,
        temperature: 0.95,
        system: '–¢—ã –ù–∞—Å—Ç—è ‚Äî —è–∑–≤–∏—Ç–µ–ª—å–Ω–∞—è, —Å–∞—Ä–∫–∞—Å—Ç–∏—á–Ω–∞—è –ø–æ–¥—Ä—É–≥–∞, –∫–æ—Ç–æ—Ä–∞—è –ø–∏—à–µ—Ç –Ω–∞ —Ä—É—Å—Å–∫–æ–º. –í—Å–µ–≥–¥–∞ –æ—Ç–≤–µ—á–∞–π –°–¢–†–û–ì–û –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON: {"title": "–∑–∞–≥–æ–ª–æ–≤–æ–∫", "body": "—Ç–µ–∫—Å—Ç"}. –ë–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ—è—Å–Ω–µ–Ω–∏–π, —Ç–æ–ª—å–∫–æ JSON.',
        messages: [
          {
            role: 'user',
            content: prompt + '\n\n–í–µ—Ä–Ω–∏ –æ—Ç–≤–µ—Ç –°–¢–†–û–ì–û –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON:\n{"title": "—Ç–µ–∫—Å—Ç –∑–∞–≥–æ–ª–æ–≤–∫–∞", "body": "—Ç–µ–∫—Å—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"}',
          },
        ],
      }),
    });

    if (!response.ok) {
      throw new Error(`Claude API error: ${response.status} ${response.statusText}`);
    }

    const payload = await response.json();
    const raw = payload?.content?.[0]?.text;
    if (!raw) {
      throw new Error('Claude returned empty content');
    }

    // Claude –º–æ–∂–µ—Ç –æ–±–µ—Ä–Ω—É—Ç—å JSON –≤ markdown –±–ª–æ–∫
    const cleanContent = raw.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    const parsed = JSON.parse(cleanContent);
    if (!parsed.title || !parsed.body) {
      throw new Error('Claude response missing fields');
    }

    if (!isValidPersonaTitle(parsed.title)) {
      throw new Error(`Generated title does not meet persona format: "${parsed.title}"`);
    }

    const normalized = {
      title: parsed.title.trim(),
      body: ensureEmojiPresent(parsed.body.trim()),
    };

    cache.set(type, normalized);
    return normalized;
  } catch (error) {
    console.warn(`Falling back to canned text for type ${type}:`, error.message);
    const fallback = {
      title: fallbackMessages[type].title,
      body: ensureEmojiPresent(fallbackMessages[type].body),
    };
    cache.set(type, fallback);
    return fallback;
  }
}

async function loadNotificationsLog(username) {
  const fallback = {
    notifications: [],
    lastUpdated: new Date().toISOString(),
  };

  const result = await loadRepoJson(username, 'nastia-notifications.json', fallback);

  // If the file was corrupted, force save to fix it
  if (result.corrupted) {
    console.warn('Notifications log was corrupted or missing, recreating...');
    try {
      await saveNotificationsLog(username, fallback);
      console.log('Notifications log recreated successfully');
    } catch (error) {
      console.error('Failed to recreate notifications log:', error.message);
    }
  }

  const data = result.value;
  if (!Array.isArray(data.notifications)) {
    data.notifications = [];
  }
  return data;
}

async function saveNotificationsLog(username, log) {
  const url = `https://api.github.com/repos/${username}/nastia-data/contents/nastia-notifications.json`;

  const content = Buffer.from(JSON.stringify(log, null, 2)).toString('base64');

  let sha;
  const getResponse = await fetch(url, {
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      Accept: 'application/vnd.github.v3+json',
    },
  });

  if (getResponse.ok) {
    const fileData = await getResponse.json();
    sha = fileData.sha;
  }

  const putResponse = await fetch(url, {
    method: 'PUT',
    headers: {
      Authorization: `token ${GITHUB_TOKEN}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      message: `Update notifications log ${new Date().toISOString()}`,
      content,
      ...(sha ? { sha } : {}),
    }),
  });

  if (!putResponse.ok) {
    const errorPayload = await putResponse.text();
    throw new Error(`Failed to save notifications log: ${errorPayload}`);
  }
}

function buildNotificationPayload(type, message, today) {
  return {
    id: `${today.toISOString()}-${type}`,
    type,
    title: message.title,
    body: message.body,
    sentAt: new Date().toISOString(),
  };
}

async function main() {
  try {
    const userResponse = await fetchFromGitHub('https://api.github.com/user');
    if (!userResponse.ok) {
      throw new Error('Failed to fetch GitHub user');
    }
    const userData = await userResponse.json();
    const username = userData.login;

    const trimmedClaudeKey = (CLAUDE_API_KEY || '').trim();
    const { schedule } = await prepareConfigAndSchedule(username, trimmedClaudeKey);

    const berlinNow = getBerlinNow();
    const berlinMinutesNow = getMinutesSinceMidnight(berlinNow);
    const currentBerlinTime = formatClock(berlinNow);

    console.log(`Current time in ${BERLIN_TZ}: ${currentBerlinTime}`);
    console.log(`Planned notification time: ${schedule.targetTime} (${BERLIN_TZ})`);

    if (berlinMinutesNow < schedule.targetMinutes) {
      console.log('Notification window not reached yet, skipping this run');
      return;
    }

    const notificationsLog = await loadNotificationsLog(username);
    const todaysNotification = getLatestNotificationForDay(notificationsLog, schedule.dayKey);
    if (todaysNotification) {
      const sentClock = formatBerlinClockFromIso(todaysNotification.sentAt);
      console.log(`Notification already sent today at ${sentClock} (${BERLIN_TZ}), skipping`);
      return;
    }

    let nastiaDataResult = await loadRepoJson(username, 'nastia-cycles.json', null);
    let nastiaData = nastiaDataResult.value;

    if (!nastiaData) {
      nastiaDataResult = await loadRepoJson(username, 'nastia-data.json', null);
      nastiaData = nastiaDataResult.value;
    }

    const cycleCount = nastiaData?.cycles?.length ?? 0;
    console.log(`Cycles loaded: ${cycleCount}`);

    const subscriptionsResult = await loadRepoJson(username, 'subscriptions.json', {
      subscriptions: [],
      lastUpdated: new Date().toISOString(),
    });
    const subscriptionsData = subscriptionsResult.value;

    console.log(`Subscriptions loaded: ${subscriptionsData.subscriptions.length}`);

    if (!nastiaData || !nastiaData.cycles || nastiaData.cycles.length === 0) {
      console.log('No cycles available, skipping notifications');
      return;
    }

    const stats = computeCycleStats(nastiaData.cycles);
    if (!stats) {
      console.log('Not enough data to compute stats');
      return;
    }

    const today = getMoscowToday();
    console.log('Today (Moscow):', today.toISOString());
    console.log('Next period:', stats.nextPeriod.toISOString(), 'Ovulation:', stats.ovulationDay.toISOString(), 'Fertile start:', stats.fertileStart.toISOString());

    const typeInfo = pickNotificationType(today, stats);

    if (!typeInfo) {
      console.log('No notification planned for today', {
        daysUntilPeriod: diffInDays(today, stats.nextPeriod),
        daysUntilOvulation: diffInDays(today, stats.ovulationDay),
      });
      return;
    }

    const { type, metadata } = typeInfo;
    console.log('Notification type selected:', type, metadata);
    const messageCache = new Map();

    const predictedDate = (() => {
      const iso = metadata?.predictedDateIso ?? stats.nextPeriod.toISOString();
      const candidate = new Date(iso);
      if (Number.isNaN(candidate.getTime())) {
        return startOfDay(stats.nextPeriod);
      }
      return startOfDay(candidate);
    })();

    const periodStartDate = (() => {
      const iso = metadata?.periodStartDate ?? (stats.lastStart ? stats.lastStart.toISOString() : null);
      if (!iso) {
        return null;
      }
      const candidate = new Date(iso);
      if (Number.isNaN(candidate.getTime())) {
        return null;
      }
      return startOfDay(candidate);
    })();

    const resolvedDaysUntilPeriod = metadata?.daysUntilPeriod ?? diffInDays(today, predictedDate);
    const resolvedDaysUntilOvulation = metadata?.daysUntilOvulation ?? diffInDays(today, stats.ovulationDay);
    const resolvedDaysPastPrediction =
      metadata?.daysPastPrediction ?? (resolvedDaysUntilPeriod < 0 ? Math.abs(resolvedDaysUntilPeriod) : 0);

    let resolvedDaysSincePeriodStart =
      typeof metadata?.daysSincePeriodStart === 'number' ? metadata.daysSincePeriodStart : null;
    if (resolvedDaysSincePeriodStart === null && periodStartDate) {
      const sinceStart = diffInDays(periodStartDate, today);
      if (sinceStart >= 0) {
        resolvedDaysSincePeriodStart = sinceStart;
      }
    }

    const context = {
      todayHuman: formatRussianDate(today),
      periodHuman: formatRussianDate(predictedDate),
      daysUntilPeriod: resolvedDaysUntilPeriod,
      daysUntilPeriodWord: getDaysWord(Math.abs(resolvedDaysUntilPeriod)),
      daysUntilOvulation: resolvedDaysUntilOvulation,
      daysWord: getDaysWord(
        Math.abs(
          metadata?.daysUntilPeriod ??
          metadata?.daysUntilOvulation ??
          resolvedDaysUntilPeriod
        )
      ),
      daysPastPrediction: resolvedDaysPastPrediction,
      daysPastPredictionWord: getDaysWord(Math.abs(resolvedDaysPastPrediction)),
      periodStartHuman: periodStartDate ? formatRussianDate(periodStartDate) : null,
      daysSincePeriodStart: resolvedDaysSincePeriodStart,
      daysSincePeriodStartWord:
        resolvedDaysSincePeriodStart != null ? getDaysWord(Math.abs(resolvedDaysSincePeriodStart)) : null,
      birthdayHuman: formatRussianDate(today),
      birthdayAge: typeof metadata?.birthdayAge === 'number' ? metadata.birthdayAge : getNastiaAgeOn(today),
      isBirthday: isNastiaBirthday(today),
    };

    let sent = 0;
    let logEntry;

    for (const subscription of subscriptionsData.subscriptions) {
      const settings = subscription.settings || {};
      const enabled = settings.enabled !== false;
      if (!enabled) {
        continue;
      }

      const pushSubscription = {
        endpoint: subscription.endpoint,
        keys: subscription.keys,
      };

      const message = await generateMessage(type, context, messageCache);
      if (!logEntry) {
        logEntry = buildNotificationPayload(type, message, today);
      }

      console.log('Sending notification with context:', context);

      const payload = JSON.stringify({
        title: message.title,
        body: message.body,
        id: logEntry.id,
        type,
        sentAt: logEntry.sentAt,
      });

      try {
        await webpush.sendNotification(
          pushSubscription,
          Buffer.from(payload, 'utf-8'),
          {
            contentEncoding: 'aes128gcm'
          }
        );
        sent += 1;
        console.log(`Notification (${type}) sent to ${subscription.endpoint.slice(-20)}`);
      } catch (error) {
        const status = error?.statusCode ?? error?.status ?? 'unknown-status';
        const responseBody = error?.body ? error.body.toString() : undefined;
        console.error(`Failed to send to ${subscription.endpoint.slice(-20)}:`, error.message, status, responseBody);
      }
    }

    if (sent > 0 && logEntry) {
      notificationsLog.notifications.unshift(logEntry);
      notificationsLog.notifications = notificationsLog.notifications.slice(0, 200);
      notificationsLog.lastUpdated = new Date().toISOString();
      try {
        await saveNotificationsLog(username, notificationsLog);
      } catch (error) {
        console.error('Failed to persist notifications log:', error.message);
      }
    }

    console.log(`Total notifications sent: ${sent}`);
  } catch (error) {
    console.error('Error in notification job:', error);
    process.exit(1);
  }
}

main();
